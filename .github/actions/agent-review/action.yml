name: 'Agent Review'
description: 'Runs AI-powered review for a specific agent with conditional execution'

# Required permissions (must be set in calling workflow):
#   contents: read       - For repository access (checkout must be done in calling workflow)
#   pull-requests: write - For posting review comments (via ai-review action)
#
# IMPORTANT: Calling workflow MUST checkout repository BEFORE using this action
# Example:
#   steps:
#     - name: Checkout repository
#       uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5
#     - name: Run review
#       uses: ./.github/actions/agent-review

inputs:
  agent:
    description: 'Agent name (security, qa, analyst, architect, devops, roadmap)'
    required: true
  emoji:
    description: 'Emoji for agent display'
    required: true
  prompt-file:
    description: 'Path to agent prompt file'
    required: true
  should-run:
    description: 'Whether to execute review (from check-changes output)'
    required: true
  pr-number:
    description: 'Pull request number'
    required: true
  bot-pat:
    description: 'Bot PAT for GitHub API'
    required: true
  copilot-token:
    description: 'GitHub Copilot token'
    required: true
  additional-context:
    description: 'Additional context to pass to the AI agent (e.g., pre-executed test results)'
    required: false
    default: ''
  commit-sha:
    description: 'Commit SHA for cache key (same commit = same diff = cache hit)'
    required: false
    default: ''
  bypass-cache:
    description: 'Bypass cached results and force fresh Copilot API call'
    required: false
    default: 'false'

outputs:
  verdict:
    description: 'Review verdict (PASS, WARN, FAIL, CRITICAL_FAIL, REJECTED, NEEDS_REVIEW)'
    value: ${{ steps.cache.outputs.cache-hit == 'true' && steps.cached-results.outputs.verdict || steps.review.outputs.verdict }}
  findings:
    description: 'Review findings'
    value: ${{ steps.cache.outputs.cache-hit == 'true' && steps.cached-results.outputs.findings || steps.review.outputs.findings }}
  infrastructure-failure:
    description: 'Whether review failed due to infrastructure issues'
    value: ${{ steps.cache.outputs.cache-hit == 'true' && steps.cached-results.outputs.infrastructure_failure || steps.review.outputs.infrastructure-failure }}
  retry-count:
    description: 'Number of retries attempted'
    value: ${{ steps.cache.outputs.cache-hit == 'true' && '0' || steps.review.outputs.retry-count }}
  cache-hit:
    description: 'Whether cached results were used'
    value: ${{ steps.cache.outputs.cache-hit == 'true' && 'true' || 'false' }}

runs:
  using: 'composite'
  steps:
    # CWE-22 mitigation: validate agent name before any file path usage
    - name: Validate agent name
      if: inputs.should-run == 'true'
      shell: bash
      env:
        AGENT: ${{ inputs.agent }}
      run: |
        if [[ ! "$AGENT" =~ ^[a-zA-Z0-9_-]+$ ]]; then
          echo "::error::Invalid agent name: $AGENT. Must match '^[a-zA-Z0-9_-]+$'."
          exit 1
        fi

    # Cache check: restore previous review results for same commit + prompt
    - name: Restore cached review
      if: inputs.should-run == 'true' && inputs.commit-sha != '' && inputs.bypass-cache != 'true'
      id: cache
      uses: actions/cache/restore@5a3ec84eff668545956fd18022155c47e93e2684 # v4
      with:
        path: ai-review-cache/${{ inputs.agent }}
        key: ai-review-${{ inputs.agent }}-${{ inputs.commit-sha }}-${{ hashFiles(inputs.prompt-file) }}

    - name: Load cached results
      if: inputs.should-run == 'true' && steps.cache.outputs.cache-hit == 'true'
      id: cached-results
      shell: bash
      env:
        AGENT: ${{ inputs.agent }}
      run: |
        if [[ ! "$AGENT" =~ ^[a-zA-Z0-9_-]+$ ]]; then
          echo "::error::Invalid agent name: $AGENT. Must match '^[a-zA-Z0-9_-]+$'."
          exit 1
        fi
        echo "Cache hit for $AGENT review, skipping Copilot API call"
        CACHE_DIR="ai-review-cache/$AGENT"
        echo "verdict=$(cat "$CACHE_DIR/verdict.txt")" >> $GITHUB_OUTPUT
        echo "infrastructure_failure=$(cat "$CACHE_DIR/infrastructure-failure.txt" 2>/dev/null || echo false)" >> $GITHUB_OUTPUT
        echo "retry_count=0" >> $GITHUB_OUTPUT
        # Use a randomized delimiter to prevent collision with findings content
        DELIMITER="EOF_CACHED_FINDINGS_${RANDOM}_${RANDOM}"
        {
          echo "findings<<${DELIMITER}"
          cat "$CACHE_DIR/findings.txt"
          echo "${DELIMITER}"
        } >> $GITHUB_OUTPUT

    - name: ${{ inputs.emoji }} ${{ inputs.agent }} Review
      if: inputs.should-run == 'true' && steps.cache.outputs.cache-hit != 'true'
      id: review
      uses: ./.github/actions/ai-review
      with:
        agent: ${{ inputs.agent }}
        context-type: pr-diff
        pr-number: ${{ inputs.pr-number }}
        prompt-file: ${{ inputs.prompt-file }}
        timeout-minutes: 5
        bot-pat: ${{ inputs.bot-pat }}
        copilot-token: ${{ inputs.copilot-token }}
        additional-context: ${{ inputs.additional-context }}

    # Save results to cache directory for future runs
    - name: Populate cache directory
      if: always() && inputs.should-run == 'true' && steps.cache.outputs.cache-hit != 'true' && inputs.commit-sha != ''
      shell: bash
      env:
        AGENT: ${{ inputs.agent }}
        VERDICT: ${{ steps.review.outputs.verdict }}
        FINDINGS: ${{ steps.review.outputs.findings }}
        INFRA_FAILURE: ${{ steps.review.outputs.infrastructure-failure }}
      run: |
        if [[ ! "$AGENT" =~ ^[a-zA-Z0-9_-]+$ ]]; then
          echo "::error::Invalid agent name: $AGENT. Must match '^[a-zA-Z0-9_-]+$'."
          exit 1
        fi
        # Only cache successful reviews (not infrastructure failures)
        if [ "$INFRA_FAILURE" = "true" ]; then
          echo "Skipping cache save: infrastructure failure"
          exit 0
        fi
        CACHE_DIR="ai-review-cache/$AGENT"
        mkdir -p "$CACHE_DIR"
        printf '%s' "${VERDICT:-NEEDS_REVIEW}" > "$CACHE_DIR/verdict.txt"
        printf '%s' "$FINDINGS" > "$CACHE_DIR/findings.txt"
        printf '%s' "${INFRA_FAILURE:-false}" > "$CACHE_DIR/infrastructure-failure.txt"
        echo "Populated cache directory for $AGENT"

    - name: Save cache
      if: always() && inputs.should-run == 'true' && steps.cache.outputs.cache-hit != 'true' && inputs.commit-sha != ''
      uses: actions/cache/save@5a3ec84eff668545956fd18022155c47e93e2684 # v4
      with:
        path: ai-review-cache/${{ inputs.agent }}
        key: ai-review-${{ inputs.agent }}-${{ inputs.commit-sha }}-${{ hashFiles(inputs.prompt-file) }}
      continue-on-error: true

    - name: Save review results
      if: always() && inputs.should-run == 'true'
      shell: pwsh -NoProfile -Command "& '{0}'"
      env:
        AGENT: ${{ inputs.agent }}
        VERDICT: ${{ steps.cache.outputs.cache-hit == 'true' && steps.cached-results.outputs.verdict || steps.review.outputs.verdict }}
        FINDINGS: ${{ steps.cache.outputs.cache-hit == 'true' && steps.cached-results.outputs.findings || steps.review.outputs.findings }}
        INFRASTRUCTURE_FAILURE: ${{ steps.cache.outputs.cache-hit == 'true' && steps.cached-results.outputs.infrastructure_failure || steps.review.outputs.infrastructure-failure }}
        RETRY_COUNT: ${{ steps.cache.outputs.cache-hit == 'true' && '0' || steps.review.outputs.retry-count }}
        CACHE_HIT: ${{ steps.cache.outputs.cache-hit }}
      run: |
        $ErrorActionPreference = 'Stop'
        # CWE-22 mitigation: Validate agent name against allowlist
        $allowedAgents = @('security', 'qa', 'analyst', 'architect', 'devops', 'roadmap')
        if ($env:AGENT -notin $allowedAgents) {
          throw "Invalid agent name: $($env:AGENT). Must be one of: $($allowedAgents -join ', ')"
        }

        # Default empty verdict to NEEDS_REVIEW so aggregate job can process it
        $verdict = $env:VERDICT
        if ([string]::IsNullOrWhiteSpace($verdict)) {
          $verdict = 'NEEDS_REVIEW'
          Write-Output "::warning::Verdict was empty, defaulting to NEEDS_REVIEW"
        }

        if ($env:CACHE_HIT -eq 'true') {
          Write-Output "Using cached review result for $($env:AGENT)"
        }

        $basePath = "ai-review-results"
        New-Item -ItemType Directory -Path $basePath -Force | Out-Null
        $verdict | Set-Content "$basePath/$($env:AGENT)-verdict.txt" -NoNewline
        $env:FINDINGS | Set-Content "$basePath/$($env:AGENT)-findings.txt" -NoNewline
        $env:INFRASTRUCTURE_FAILURE | Set-Content "$basePath/$($env:AGENT)-infrastructure-failure.txt" -NoNewline
        $env:RETRY_COUNT | Set-Content "$basePath/$($env:AGENT)-retry-count.txt" -NoNewline
        Write-Output "Saved $($env:AGENT) results:"
        Write-Output "  Verdict: $verdict"
        Write-Output "  Findings: $((Get-Item "$basePath/$($env:AGENT)-findings.txt").Length) bytes"
        Write-Output "  Infrastructure failure: $($env:INFRASTRUCTURE_FAILURE)"
        Write-Output "  Retry count: $($env:RETRY_COUNT)"
        Write-Output "  Cache hit: $($env:CACHE_HIT)"

    - name: Upload review results
      if: always() && inputs.should-run == 'true'
      uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
      with:
        name: review-${{ inputs.agent }}
        path: ai-review-results/
        retention-days: 1

    - name: Generate step summary
      if: always() && inputs.should-run == 'true'
      shell: python3 {0}
      env:
        AGENT: ${{ inputs.agent }}
        EMOJI: ${{ inputs.emoji }}
        VERDICT: ${{ steps.cache.outputs.cache-hit == 'true' && steps.cached-results.outputs.verdict || steps.review.outputs.verdict }}
        FINDINGS: ${{ steps.cache.outputs.cache-hit == 'true' && steps.cached-results.outputs.findings || steps.review.outputs.findings }}
        RUN_ID: ${{ github.run_id }}
        SERVER_URL: ${{ github.server_url }}
        REPOSITORY: ${{ github.repository }}
        PR_NUMBER: ${{ inputs.pr-number }}
        CACHE_HIT: ${{ steps.cache.outputs.cache-hit }}
      run: |
        import os
        import sys

        # Add workspace root to path so 'scripts' package resolves
        sys.path.insert(0, os.environ['GITHUB_WORKSPACE'])

        from scripts.ai_review_common.issue_triage import get_verdict_alert_type, get_verdict_emoji

        try:
            verdict = os.environ.get('VERDICT', '').strip()
            if not verdict:
                print("::warning::VERDICT environment variable is missing or empty, defaulting to NEEDS_REVIEW")
                verdict = "NEEDS_REVIEW"

            agent = os.environ.get('AGENT', '')
            emoji = os.environ.get('EMOJI', '')
            findings = os.environ.get('FINDINGS', '')
            run_id = os.environ.get('RUN_ID', '')
            server_url = os.environ.get('SERVER_URL', '')
            repository = os.environ.get('REPOSITORY', '')
            pr_number = os.environ.get('PR_NUMBER', '')

            alert_type = get_verdict_alert_type(verdict)
            verdict_emoji = get_verdict_emoji(verdict)
            agent_display = agent.title() if agent else "Unknown"
            cache_hit = os.environ.get('CACHE_HIT', '') == 'true'
            cache_label = " (cached)" if cache_hit else ""

            lines = [
                f"## {emoji} {agent_display} Review{cache_label}",
                "",
                f"> [!{alert_type}]",
                f"> {verdict_emoji} **Verdict: {verdict}**{cache_label}",
                "",
                "<details>",
                "<summary>Review Findings</summary>",
                "",
                findings,
                "",
                "</details>",
                "",
                "---",
                "",
                f"<sub>üí° See the [workflow run]({server_url}/{repository}/actions/runs/{run_id})"
                " for full context across all agents, or check the PR for the"
                " consolidated quality gate comment.</sub>",
            ]
            summary = "\n".join(lines) + "\n"

            with open(os.environ['GITHUB_STEP_SUMMARY'], 'a', encoding='utf-8') as f:
                f.write(summary)

        except Exception as e:
            print(f"::error::Failed to generate step summary: {e}")
            print(f"::error::Verdict: {os.environ.get('VERDICT', 'N/A')}")
            print(f"::error::Agent: {os.environ.get('AGENT', 'N/A')}")
            sys.exit(1)

    - name: Check verdict and fail if needed
      if: always() && inputs.should-run == 'true'
      shell: pwsh -NoProfile -Command "& '{0}'"
      env:
        AGENT: ${{ inputs.agent }}
        EMOJI: ${{ inputs.emoji }}
        VERDICT: ${{ steps.cache.outputs.cache-hit == 'true' && steps.cached-results.outputs.verdict || steps.review.outputs.verdict }}
        FINDINGS: ${{ steps.cache.outputs.cache-hit == 'true' && steps.cached-results.outputs.findings || steps.review.outputs.findings }}
        INFRASTRUCTURE_FAILURE: ${{ steps.cache.outputs.cache-hit == 'true' && steps.cached-results.outputs.infrastructure_failure || steps.review.outputs.infrastructure-failure }}
      run: |
        $ErrorActionPreference = 'Stop'
        $agent = $env:AGENT
        $emoji = $env:EMOJI
        $verdict = $env:VERDICT
        $findings = $env:FINDINGS

        # Default empty verdict to NEEDS_REVIEW (blocking) so failures are not silently passed
        if ([string]::IsNullOrWhiteSpace($verdict)) {
          $verdict = 'NEEDS_REVIEW'
          Write-Output "::warning::Verdict was empty, defaulting to NEEDS_REVIEW"
        }

        $blockingVerdicts = @('CRITICAL_FAIL', 'REJECTED', 'FAIL', 'NEEDS_REVIEW')

        # Infrastructure failures should not block the PR (aggregate handles downgrade to WARN)
        if ($verdict -in $blockingVerdicts -and $env:INFRASTRUCTURE_FAILURE -eq 'true') {
          Write-Output "::warning::[$agent] Infrastructure failure (verdict: $verdict). Not blocking PR."
          Write-Output ""
          Write-Output "‚ö†Ô∏è $emoji $agent review had infrastructure failure (Copilot CLI unavailable)"
          Write-Output ""
          Write-Output "Verdict downgraded by aggregate step. See workflow summary for details."
          exit 0
        }

        if ($verdict -in $blockingVerdicts) {
          $maxAnnotationLength = 180
          if ([string]::IsNullOrWhiteSpace($findings)) {
            $summary = "Review failed but no details were provided by the AI model"
            Write-Output "::warning::[$agent] Verdict is $verdict but findings are empty"
          } else {
            $summary = ($findings -replace "`n", " ")
            if ($summary.Length -gt $maxAnnotationLength) {
              $summary = $summary.Substring(0, $maxAnnotationLength - 3) + "..."
            }
          }

          # Infrastructure failures are not code quality issues. Downgrade to warning
          # so the aggregate job can determine the final verdict holistically.
          if ($env:INFRASTRUCTURE_FAILURE -eq 'true') {
            Write-Output "::warning::[$agent] ${verdict}: $summary (infrastructure failure, downgrading to warning)"
            Write-Output ""
            Write-Output "‚ö†Ô∏è $emoji $agent review had infrastructure failure (verdict: $verdict)"
            Write-Output ""
            Write-Output "Infrastructure failures are non-blocking. See aggregate results for final verdict."
          } else {
            Write-Output "::error::[$agent] ${verdict}: $summary"
            Write-Output ""
            Write-Output "‚ùå $emoji $agent review failed with verdict: $verdict"
            Write-Output ""
            Write-Output "See the step summary above for full findings."
            exit 1
          }
        } else {
          Write-Output "‚úÖ $emoji $agent review passed with verdict: $verdict"
        }

    - name: Skip ${{ inputs.agent }} review (no relevant changes)
      if: inputs.should-run != 'true'
      shell: pwsh -NoProfile -Command "& '{0}'"
      env:
        AGENT: ${{ inputs.agent }}
      run: |
        $ErrorActionPreference = 'Stop'
        Write-Output "‚úÖ $env:AGENT review skipped - no relevant file changes detected"
        Write-Output ""
        Write-Output "This PR only contains changes to files that don't require AI review."
        Write-Output "Status: PASS (skipped)"
