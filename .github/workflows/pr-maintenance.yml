name: PR Maintenance

on:
  schedule:
    - cron: '0 * * * *'  # Hourly at minute 0 (UTC)
  workflow_dispatch:     # Manual trigger
    inputs:
      max_prs:
        description: 'Max PRs to process'
        type: number
        default: 20
      process_conflicts:
        description: 'Auto-resolve merge conflicts'
        type: boolean
        default: true

permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: read  # Required for workflow status checks

concurrency:
  group: pr-maintenance
  cancel-in-progress: false

env:
  PR_MAX_PRS: ${{ inputs.max_prs || 20 }}

jobs:
  # Job 1: Discover PRs needing attention
  discover-prs:
    runs-on: ubuntu-24.04-arm
    timeout-minutes: 10
    outputs:
      matrix: ${{ steps.discover.outputs.matrix }}
      has-prs: ${{ steps.discover.outputs.has-prs }}
      summary-json: ${{ steps.discover.outputs.summary }}

    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4
        with:
          fetch-depth: 0

      - name: Check API rate limit
        id: ratelimit
        env:
          GH_TOKEN: ${{ secrets.BOT_PAT }}
        shell: pwsh -NoProfile -Command "& '{0}'"
        run: |
          $limits = gh api rate_limit 2>&1 | ConvertFrom-Json
          $core = $limits.resources.core
          $graphql = $limits.resources.graphql
          Write-Host "Rate limits - Core: $($core.remaining)/$($core.limit), GraphQL: $($graphql.remaining)/$($graphql.limit)"

          if ($core.remaining -lt 100 -or $graphql.remaining -lt 50) {
            Write-Host "::error::Rate limit too low to proceed"
            exit 1
          }

          "core_remaining=$($core.remaining)" | Out-File $env:GITHUB_OUTPUT -Append

      - name: Discover PRs needing attention
        id: discover
        env:
          GH_TOKEN: ${{ secrets.BOT_PAT }}
        shell: pwsh -NoProfile -Command "& '{0}'"
        run: |
          $result = ./scripts/Invoke-PRMaintenance.ps1 -MaxPRs ([int]'${{ env.PR_MAX_PRS }}') -OutputJson
          $parsed = $result | ConvertFrom-Json

          # Output for matrix - ALL PRs requiring action (for parallel processing)
          $actionPRs = @($parsed.prs)
          $matrixJson = @{ include = $actionPRs } | ConvertTo-Json -Compress -Depth 10
          "matrix=$matrixJson" | Out-File $env:GITHUB_OUTPUT -Append

          # Check if we have any PRs to process
          $hasPRs = $actionPRs.Count -gt 0
          "has-prs=$($hasPRs.ToString().ToLower())" | Out-File $env:GITHUB_OUTPUT -Append

          # Full summary for later steps
          "summary=$result" | Out-File $env:GITHUB_OUTPUT -Append

          Write-Host "Found $($parsed.summary.total) open PRs"
          Write-Host "Action Required: $($parsed.summary.actionRequired)"
          Write-Host "With Conflicts: $(@($actionPRs | Where-Object { $_.hasConflicts }).Count)"

      - name: Write step summary
        env:
          GH_TOKEN: ${{ secrets.BOT_PAT }}
        shell: pwsh -NoProfile -Command "& '{0}'"
        run: |
          $json = '${{ steps.discover.outputs.summary }}'
          $parsed = $json | ConvertFrom-Json

          $summary = @"
          ## PR Discovery Summary

          | Metric | Count |
          |--------|-------|
          | Open PRs Scanned | $($parsed.summary.total) |
          | PRs Need Action | $($parsed.summary.actionRequired) |
          | Blocked (human) | $($parsed.summary.blocked) |
          | Derivative PRs | $($parsed.summary.derivatives) |

          "@

          if ($parsed.prs.Count -gt 0) {
            $summary += @"

          ### PRs Requiring Action

          | PR | Category | Reason | Has Conflicts |
          |----|----------|--------|---------------|
          "@
            foreach ($pr in $parsed.prs) {
              $conflictIcon = if ($pr.hasConflicts) { ':warning:' } else { ':white_check_mark:' }
              $summary += "| #$($pr.number) | $($pr.category) | $($pr.reason) | $conflictIcon |`n"
            }
          }

          $summary | Out-File $env:GITHUB_STEP_SUMMARY -Append

  # Job 2: Process PRs in parallel (matrix strategy)
  process-prs:
    needs: discover-prs
    if: needs.discover-prs.outputs.has-prs == 'true'
    runs-on: ubuntu-24.04-arm
    timeout-minutes: 30
    strategy:
      matrix: ${{ fromJson(needs.discover-prs.outputs.matrix) }}
      fail-fast: false
      max-parallel: 3

    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4
        with:
          fetch-depth: 0

      - name: Configure git
        run: |
          git config user.name "rjmurillo-bot"
          git config user.email "rjmurillo-bot@users.noreply.github.com"

      - name: Auto-resolve conflicts for PR #${{ matrix.number }}
        id: auto-resolve
        if: matrix.hasConflicts == true && (inputs.process_conflicts != false)
        env:
          GH_TOKEN: ${{ secrets.BOT_PAT }}
        shell: pwsh -NoProfile -Command "& '{0}'"
        run: |
          Write-Host "Attempting auto-resolution for PR #${{ matrix.number }}"
          Write-Host "Branch: ${{ matrix.headRefName }} -> ${{ matrix.baseRefName }}"

          $result = ./.claude/skills/merge-resolver/scripts/Resolve-PRConflicts.ps1 `
            -PRNumber ${{ matrix.number }} `
            -BranchName '${{ matrix.headRefName }}' `
            -TargetBranch '${{ matrix.baseRefName }}'

          $parsed = $result | ConvertFrom-Json
          if ($parsed.Success) {
            Write-Host "::notice::PR #${{ matrix.number }}: Auto-resolved - $($parsed.FilesResolved.Count) file(s)"
            "needs_ai=false" | Out-File $env:GITHUB_OUTPUT -Append
          } else {
            Write-Host "::warning::PR #${{ matrix.number }}: Auto-resolution blocked on: $($parsed.FilesBlocked -join ', ')"
            "needs_ai=true" | Out-File $env:GITHUB_OUTPUT -Append
            "blocked_files=$($parsed.FilesBlocked | ConvertTo-Json -Compress)" | Out-File $env:GITHUB_OUTPUT -Append
          }

      - name: Prepare conflict context for AI analysis
        id: conflict-context
        if: steps.auto-resolve.outputs.needs_ai == 'true'
        env:
          GH_TOKEN: ${{ secrets.BOT_PAT }}
        shell: pwsh -NoProfile -Command "& '{0}'"
        run: |
          # Checkout PR branch and attempt merge to get conflict state
          git fetch origin '${{ matrix.headRefName }}'
          git checkout '${{ matrix.headRefName }}'
          git fetch origin '${{ matrix.baseRefName }}'

          # Attempt merge (will create conflict markers)
          $null = git merge "origin/${{ matrix.baseRefName }}" 2>&1

          # Gather conflict context with git blame analysis
          $blockedFiles = '${{ steps.auto-resolve.outputs.blocked_files }}' | ConvertFrom-Json
          $context = @()

          foreach ($file in $blockedFiles) {
            $context += "### File: $file"
            $context += ""
            $context += "#### Conflict markers:"
            $context += '```'
            $content = Get-Content $file -Raw -ErrorAction SilentlyContinue
            if ($content) {
              # Extract just the conflict sections
              $content -split "`n" | Where-Object { $_ -match '^(<<<<<<<|=======|>>>>>>>|[^<=>].*)' } |
                Select-Object -First 100 | ForEach-Object { $context += $_ }
            }
            $context += '```'
            $context += ""

            # Get recent commits for this file on both branches
            $context += "#### Recent commits (PR branch):"
            $context += '```'
            git log --oneline -5 HEAD -- $file 2>$null | ForEach-Object { $context += $_ }
            $context += '```'
            $context += ""
            $context += "#### Recent commits (base branch):"
            $context += '```'
            git log --oneline -5 "origin/${{ matrix.baseRefName }}" -- $file 2>$null | ForEach-Object { $context += $_ }
            $context += '```'
            $context += ""
          }

          $contextStr = $context -join "`n"
          # Escape for GitHub Actions output
          $contextStr = $contextStr -replace '%', '%25' -replace "`n", '%0A' -replace "`r", '%0D'
          "conflict_context=$contextStr" | Out-File $env:GITHUB_OUTPUT -Append

          # Abort the merge so we can try again after AI analysis
          git merge --abort 2>$null

      - name: AI conflict analysis
        id: ai-analysis
        if: steps.auto-resolve.outputs.needs_ai == 'true'
        uses: ./.github/actions/ai-review
        with:
          agent: analyst
          context-type: pr-diff
          pr-number: ${{ matrix.number }}
          additional-context: |
            ## Merge Conflict Analysis Request

            The following files have conflicts that could not be auto-resolved:
            ${{ steps.auto-resolve.outputs.blocked_files }}

            ${{ steps.conflict-context.outputs.conflict_context }}
          prompt-file: .github/prompts/merge-conflict-analysis.md
          timeout-minutes: 5
          bot-pat: ${{ secrets.BOT_PAT }}
          copilot-token: ${{ secrets.COPILOT_GITHUB_TOKEN }}

      - name: Apply AI conflict resolution
        if: steps.auto-resolve.outputs.needs_ai == 'true' && steps.ai-analysis.outputs.verdict == 'PASS'
        env:
          GH_TOKEN: ${{ secrets.BOT_PAT }}
          AI_FINDINGS: ${{ steps.ai-analysis.outputs.findings }}
        shell: pwsh -NoProfile -Command "& '{0}'"
        run: |
          Write-Host "Applying AI-recommended conflict resolutions for PR #${{ matrix.number }}"

          # Parse AI output to find resolutions JSON
          $findings = $env:AI_FINDINGS
          $resolutions = $null

          # Extract JSON from AI output (handle markdown code fences if present)
          $jsonContent = $findings
          # Remove markdown code fences if present (```json ... ```)
          if ($findings -match '```(?:json)?\s*([\s\S]*?)```') {
            $jsonContent = $Matches[1].Trim()
          }

          # Extract JSON object containing resolutions
          if ($jsonContent -match '\{[\s\S]*"resolutions"[\s\S]*\}') {
            try {
              $resolutions = $Matches[0] | ConvertFrom-Json
            } catch {
              Write-Host "::error::Failed to parse AI resolutions JSON: $_"
              Write-Host "::error::Raw JSON attempted: $($Matches[0].Substring(0, [Math]::Min(500, $Matches[0].Length)))"
              exit 1
            }
          }

          # Validate resolutions exist and are not empty
          if (-not $resolutions) {
            Write-Host "::error::No JSON object with 'resolutions' key found in AI output"
            exit 1
          }
          if (-not $resolutions.resolutions) {
            Write-Host "::error::AI output missing 'resolutions' array"
            exit 1
          }
          if ($resolutions.resolutions.Count -eq 0) {
            Write-Host "::error::AI returned empty resolutions array - cannot resolve conflicts"
            exit 1
          }

          # Checkout PR branch and merge
          git fetch origin '${{ matrix.headRefName }}'
          git checkout '${{ matrix.headRefName }}'
          git fetch origin '${{ matrix.baseRefName }}'
          $null = git merge "origin/${{ matrix.baseRefName }}" 2>&1

          # Apply each resolution
          foreach ($res in $resolutions.resolutions) {
            Write-Host "Resolving $($res.file) with strategy: $($res.strategy)"
            Write-Host "  Reasoning: $($res.reasoning)"

            switch ($res.strategy) {
              'theirs' {
                git checkout --theirs $res.file
                git add $res.file
              }
              'ours' {
                git checkout --ours $res.file
                git add $res.file
              }
              'combine' {
                if ($res.combined_content) {
                  $res.combined_content | Set-Content $res.file -NoNewline
                  git add $res.file
                } else {
                  Write-Host "::error::Combine strategy requires combined_content for $($res.file)"
                  exit 1
                }
              }
              default {
                Write-Host "::error::Unknown strategy: $($res.strategy)"
                exit 1
              }
            }
          }

          # Verify no remaining conflicts
          $remaining = git diff --name-only --diff-filter=U
          if ($remaining) {
            Write-Host "::error::Unresolved conflicts remain: $remaining"
            git merge --abort
            exit 1
          }

          # Commit and push
          git commit -m "Merge ${{ matrix.baseRefName }} into ${{ matrix.headRefName }} - AI-resolved conflicts"
          git push origin '${{ matrix.headRefName }}'
          Write-Host "::notice::PR #${{ matrix.number }}: AI-resolved conflicts successfully"

      - name: Report unresolvable conflicts
        if: steps.auto-resolve.outputs.needs_ai == 'true' && steps.ai-analysis.outputs.verdict != 'PASS'
        run: |
          echo "::error::PR #${{ matrix.number }}: Conflicts require manual resolution"
          echo "::error::AI verdict: ${{ steps.ai-analysis.outputs.verdict }}"
          echo "::error::Blocked files: ${{ steps.auto-resolve.outputs.blocked_files }}"
          echo "Use /merge-resolver ${{ matrix.number }} for manual resolution"
          exit 1

      # Gate: Check for human approval before bot responds to reviews (see #361)
      - name: Check human approval gate for PR #${{ matrix.number }}
        id: approval-gate
        if: |
          matrix.hasConflicts != true ||
          steps.auto-resolve.outputs.needs_ai != 'true' ||
          steps.ai-analysis.outputs.verdict == 'PASS'
        env:
          GH_TOKEN: ${{ secrets.BOT_PAT }}
        shell: pwsh -NoProfile -Command "& '{0}'"
        run: |
          # Check if PR has human approval label for bot responses
          $prData = gh pr view ${{ matrix.number }} --json labels,reviews --jq '{labels: [.labels[].name], reviews: .reviews}'
          if ($LASTEXITCODE -ne 0) {
            Write-Host "::error::Failed to fetch PR data"
            exit 1
          }
          $pr = $prData | ConvertFrom-Json

          # Check for triage:approved label
          $hasApproval = $pr.labels -contains 'triage:approved'

          # Check for human CHANGES_REQUESTED (not from bots)
          $botAuthors = @('coderabbitai[bot]', 'github-actions[bot]', 'copilot-swe-agent[bot]', 'gemini-code-assist[bot]', 'rjmurillo-bot')
          $humanChangesRequested = $pr.reviews | Where-Object {
            $_.state -eq 'CHANGES_REQUESTED' -and $_.author.login -notin $botAuthors
          }

          if ($humanChangesRequested) {
            Write-Host "::warning::PR #${{ matrix.number }}: Human CHANGES_REQUESTED found - prioritize addressing this feedback first"
            "human_changes_requested=true" | Out-File $env:GITHUB_OUTPUT -Append
          } else {
            "human_changes_requested=false" | Out-File $env:GITHUB_OUTPUT -Append
          }

          if ($hasApproval) {
            Write-Host "PR #${{ matrix.number }}: triage:approved label found - proceeding with bot responses"
            "approved=true" | Out-File $env:GITHUB_OUTPUT -Append
          } else {
            Write-Host "PR #${{ matrix.number }}: No triage:approved label - skipping bot responses"
            Write-Host "Add 'triage:approved' label to allow bot responses"
            "approved=false" | Out-File $env:GITHUB_OUTPUT -Append
          }

      - name: Post triage summary for PR #${{ matrix.number }}
        if: |
          steps.approval-gate.outputs.approved == 'false' &&
          (matrix.hasConflicts != true ||
           steps.auto-resolve.outputs.needs_ai != 'true' ||
           steps.ai-analysis.outputs.verdict == 'PASS')
        env:
          GH_TOKEN: ${{ secrets.BOT_PAT }}
        shell: pwsh -NoProfile -Command "& '{0}'"
        run: |
          # Post triage summary if not already posted
          $existingComments = gh pr view ${{ matrix.number }} --json comments --jq '.comments[].body' 2>$null
          if ($existingComments -match 'TRIAGE-REQUIRED') {
            Write-Host "Triage summary already posted"
            exit 0
          }

          # Get review comments summary
          $botAuthors = @('coderabbitai[bot]', 'github-actions[bot]', 'copilot-swe-agent[bot]', 'gemini-code-assist[bot]', 'rjmurillo-bot')
          $reviews = gh api "/repos/${{ github.repository }}/pulls/${{ matrix.number }}/reviews" 2>$null | ConvertFrom-Json
          $comments = gh api "/repos/${{ github.repository }}/pulls/${{ matrix.number }}/comments" 2>$null | ConvertFrom-Json

          $humanReviews = @($reviews | Where-Object { $_.user.login -notin $botAuthors })
          $botReviews = @($reviews | Where-Object { $_.user.login -in $botAuthors })
          $humanComments = @($comments | Where-Object { $_.user.login -notin $botAuthors })
          $botComments = @($comments | Where-Object { $_.user.login -in $botAuthors })

          $humanChangesRequested = '${{ steps.approval-gate.outputs.human_changes_requested }}' -eq 'true'
          $priority = if ($humanChangesRequested) { 'CRITICAL' } else { 'NORMAL' }
          $alertType = if ($humanChangesRequested) { 'CAUTION' } else { 'NOTE' }

          $body = @"
          <!-- TRIAGE-REQUIRED -->
          ## Review Triage Required

          > [!$alertType]
          > **Priority: $priority** - Human approval required before bot responds

          ### Review Summary

          | Source | Reviews | Comments |
          |--------|---------|----------|
          | **Human** | $($humanReviews.Count) | $($humanComments.Count) |
          | Bot | $($botReviews.Count) | $($botComments.Count) |

          $(if ($humanChangesRequested) { @"
          ### :warning: Human CHANGES_REQUESTED

          A human reviewer has requested changes. **Address this feedback first** before processing bot comments.
          "@ })

          ### Next Steps

          1. Review human feedback above
          2. Address any CHANGES_REQUESTED from human reviewers
          3. Add ``triage:approved`` label when ready for bot to respond to review comments

          ---
          <sub>Powered by PR Maintenance workflow - [Add triage:approved label](https://github.com/${{ github.repository }}/issues/${{ matrix.number }}/labels)</sub>
          "@

          gh pr comment ${{ matrix.number }} --body $body

      - name: Process PR comments for PR #${{ matrix.number }}
        id: process-comments
        # Process comments when:
        # - Human approval granted (triage:approved label) AND
        # - No conflicts, OR conflicts were resolved successfully
        if: |
          steps.approval-gate.outputs.approved == 'true' &&
          (matrix.hasConflicts != true ||
           steps.auto-resolve.outputs.needs_ai != 'true' ||
           steps.ai-analysis.outputs.verdict == 'PASS')
        uses: ./.github/actions/ai-review
        with:
          agent: pr-comment-responder
          context-type: pr-diff
          pr-number: ${{ matrix.number }}
          prompt-file: .github/prompts/pr-comment-triage.md
          execute-script: .claude/skills/github/scripts/pr/Invoke-PRCommentProcessing.ps1
          timeout-minutes: 10
          bot-pat: ${{ secrets.BOT_PAT }}
          copilot-token: ${{ secrets.COPILOT_GITHUB_TOKEN }}

      - name: Comment processing result
        if: steps.process-comments.outcome == 'success' || steps.process-comments.outcome == 'failure'
        run: |
          echo "PR #${{ matrix.number }} comment processing: ${{ steps.process-comments.outcome }}"
          echo "Verdict: ${{ steps.process-comments.outputs.verdict }}"

  # Job 3: Post-processing summary
  summarize:
    needs: [discover-prs, process-prs]
    if: always()
    runs-on: ubuntu-24.04-arm
    timeout-minutes: 5

    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4

      - name: Final summary
        env:
          GH_TOKEN: ${{ secrets.BOT_PAT }}
        shell: pwsh -NoProfile -Command "& '{0}'"
        run: |
          $json = '${{ needs.discover-prs.outputs.summary-json }}'
          if (-not $json) {
            Write-Host "No discovery results available"
            exit 0
          }

          $parsed = $json | ConvertFrom-Json
          $actionRequired = @($parsed.prs | Where-Object { $_.category -eq 'agent-controlled' })

          if ($actionRequired.Count -gt 0) {
            $prNumbers = ($actionRequired | ForEach-Object { "#$($_.number)" }) -join ", "
            Write-Host "::notice::Action required for PRs: $prNumbers"
            Write-Host "Run: /pr-review $(($actionRequired | ForEach-Object { $_.number }) -join ',')"

            $summary = @"

          ---
          ### Next Steps

          The following PRs require manual review via ``/pr-review``:

          | PR | Reason | Action |
          |----|--------|--------|
          "@
            foreach ($pr in $actionRequired) {
              $summary += "| #$($pr.number) | $($pr.reason) | ``/pr-review $($pr.number)`` |`n"
            }

            $summary | Out-File $env:GITHUB_STEP_SUMMARY -Append
          }
