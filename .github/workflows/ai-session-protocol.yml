name: Session Protocol Validation

# Deterministic session log validation using Validate-SessionProtocol.ps1

# Verifies session logs comply with RFC 2119 requirements in SESSION-PROTOCOL.md

# Blocks merge if MUST requirements are not met

# Zero-token validation: outputs structured data directly to Job Summary

on:
  pull_request:
    branches: [main]
    paths:
      - '.agents/sessions/*.md'
      - '.agents/sessions/*.json'

permissions:
  contents: read
  pull-requests: write

# Concurrency control: Attempts to cancel in-progress runs when new runs start

# NOTE: GitHub Actions does NOT guarantee run coalescing - race conditions can occur

# where multiple runs start before cancellation takes effect. This is best-effort

# See ADR-026 (../.agents/architecture/ADR-026-pr-automation-concurrency-and-safety.md)

# for architectural decision on workflow-level concurrency control

# Mitigation: Path filtering, timeouts, and PR-specific temp files reduce impact

# Note: Matrix strategy with fail-fast: false allows independent validation

concurrency:
  group: session-protocol-${{ github.event.pull_request.number }}
  cancel-in-progress: true

env:
  GH_TOKEN: ${{ secrets.BOT_PAT }}

jobs:

# Identify changed session files and build matrix

  detect-changes:
    name: Detect Changed Sessions
    # ADR-025: ARM runner for cost optimization (37.5% savings vs x64)
    runs-on: ubuntu-24.04-arm
    timeout-minutes: 3
    if: github.actor != 'dependabot[bot]' && github.actor != 'github-actions[bot]'

    outputs:
      has_sessions: ${{ steps.changed.outputs.has_sessions }}
      session_files: ${{ steps.changed.outputs.session_files }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5

      - name: Identify Changed Session Files
        id: changed
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
          GH_REPO: ${{ github.repository }}
          # Issue #215: Session End checklist requirement introduced 2025-12-21
          # Historical sessions before this date are exempt from validation
          CUTOFF_DATE: "2025-12-21"
        run: |
          # Use files API instead of gh pr diff (no line limit - fixes issue #468)
          # Include both .md (legacy) and .json (new format)
          ALL_CHANGED=$(gh api "repos/$GH_REPO/pulls/$PR_NUMBER/files" --paginate --jq '.[].filename' | grep -E '^\.agents/sessions/.*\.(md|json)$' || true)

          if [ -z "$ALL_CHANGED" ]; then
            echo "No session files changed"
            echo "has_sessions=false" >> $GITHUB_OUTPUT
            echo "session_files=[]" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "All changed session files:"
          echo "$ALL_CHANGED"

          # Filter out historical sessions (issue #215)
          # Session filename pattern: YYYY-MM-DD-session-NN.md or YYYY-MM-DD-session-NN-description.md
          CHANGED_FILES=""
          SKIPPED_FILES=""
          while IFS= read -r file; do
            # Extract date from filename (first 10 characters after path)
            filename=$(basename "$file")
            file_date="${filename:0:10}"

            # Validate date format (YYYY-MM-DD)
            if [[ "$file_date" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
              if [[ "$file_date" < "$CUTOFF_DATE" ]]; then
                SKIPPED_FILES="${SKIPPED_FILES}${file}"$'\n'
              else
                CHANGED_FILES="${CHANGED_FILES}${file}"$'\n'
              fi
            else
              # Non-standard filename, include for validation
              CHANGED_FILES="${CHANGED_FILES}${file}"$'\n'
            fi
          done <<< "$ALL_CHANGED"

          # Remove trailing newlines
          CHANGED_FILES=$(echo "$CHANGED_FILES" | sed '/^$/d')
          SKIPPED_FILES=$(echo "$SKIPPED_FILES" | sed '/^$/d')

          if [ -n "$SKIPPED_FILES" ]; then
            echo ""
            echo "Skipped historical sessions (before $CUTOFF_DATE):"
            echo "$SKIPPED_FILES"
          fi

          if [ -z "$CHANGED_FILES" ]; then
            echo ""
            echo "No validatable session files (all historical)"
            echo "has_sessions=false" >> $GITHUB_OUTPUT
            echo "session_files=[]" >> $GITHUB_OUTPUT
          else
            echo ""
            echo "Session files to validate:"
            echo "$CHANGED_FILES"
            echo "has_sessions=true" >> $GITHUB_OUTPUT

            # Convert to JSON array for matrix
            JSON_ARRAY=$(echo "$CHANGED_FILES" | jq -R -s -c 'split("\n") | map(select(length > 0))')
            echo "session_files=$JSON_ARRAY" >> $GITHUB_OUTPUT
          fi

# Validate each session file in parallel using matrix strategy

  validate:
    name: Validate ${{ matrix.session_file }}
    # ADR-025: ARM runner for cost optimization (37.5% savings vs x64)
    runs-on: ubuntu-24.04-arm
    needs: detect-changes
    if: needs.detect-changes.outputs.has_sessions == 'true'
    timeout-minutes: 5

    strategy:
      fail-fast: false # Don't cancel other validations if one fails
      matrix:
        session_file: ${{ fromJson(needs.detect-changes.outputs.session_files) }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5

      - name: Fetch origin/main for HANDOFF validation
        run: |
          # Fetch origin/main with enough history for merge-base calculation
          # The three-dot diff syntax (origin/main...HEAD) needs merge-base
          git fetch origin main --unshallow || git fetch origin main

      - name: Validate Session Protocol
        id: validate
        shell: pwsh
        env:
          SESSION_FILE: ${{ matrix.session_file }}
        run: |
          $sessionFile = $env:SESSION_FILE
          $extension = [System.IO.Path]::GetExtension($sessionFile)
          
          # Use appropriate validator based on file type
          if ($extension -eq '.json') {
            # JSON format - simple schema validation
            $result = & ./scripts/Validate-SessionJson.ps1 -SessionPath $sessionFile 2>&1
            $exitCode = $LASTEXITCODE
            $format = 'JSON'
          } else {
            # Legacy markdown format - migrate to JSON first, then validate
            Write-Host "Legacy markdown detected - migrating to JSON for validation"
            $jsonPath = $sessionFile -replace '\.md$', '.json'
            
            # Migrate
            & ./scripts/Convert-SessionToJson.ps1 -Path $sessionFile -Force 2>&1 | Out-Null
            
            if (Test-Path $jsonPath) {
              $result = & ./scripts/Validate-SessionJson.ps1 -SessionPath $jsonPath 2>&1
              $exitCode = $LASTEXITCODE
            } else {
              $result = @("Migration failed - could not convert markdown to JSON")
              $exitCode = 1
            }
            $format = 'Markdown (legacy)'
          }
          
          # Build markdown output
          $fileName = Split-Path $sessionFile -Leaf
          $status = if ($exitCode -eq 0) { 'PASS' } else { 'FAIL' }
          $mdResult = "# Session Validation: $fileName`n`nFormat: $format`nResult: $status`n`n" + '```' + "`n$($result -join "`n")`n" + '```'
          $mdResult | Out-File -FilePath "validation-result.md" -Encoding UTF8

          # Save markdown output for artifact
          $result | Out-File -FilePath "validation-result.md" -Encoding UTF8
          
          # Create simplified results directory
          New-Item -ItemType Directory -Force -Path "validation-results" | Out-Null

          # Include parent directory to prevent collisions (e.g., sessions vs archive)
          $fileInfo = Get-Item $env:SESSION_FILE
          $parentDir = $fileInfo.Directory.Name
          $baseName = [System.IO.Path]::GetFileNameWithoutExtension($fileInfo.Name)
          $fileName = "${parentDir}-${baseName}"

          # Set output for artifact naming
          "artifact-name=$fileName" >> $env:GITHUB_OUTPUT
          
          # Determine verdict based on exit code
          $verdict = if ($exitCode -eq 0) { "COMPLIANT" } else { "NON_COMPLIANT" }
          $verdict | Out-File -FilePath "validation-results/${fileName}-verdict.txt" -Encoding UTF8
          
          # Save markdown output
          $result | Out-File -FilePath "validation-results/${fileName}-findings.txt" -Encoding UTF8
          
          # Count MUST failures (look for FAIL in MUST level checks)
          # Pattern matches markdown table rows: | CheckName | MUST | FAIL |
          $mustFailCount = 0
          if ($result -match '(?m)^\|\s*\w+\s*\|\s*MUST\s*\|\s*FAIL\s*\|') {
            $mustFailCount = ([regex]::Matches($result, '(?m)^\|\s*\w+\s*\|\s*MUST\s*\|\s*FAIL\s*\|')).Count
          }
          $mustFailCount | Out-File -FilePath "validation-results/${fileName}-must-failures.txt" -Encoding UTF8
          
          Write-Host "Validation complete for $env:SESSION_FILE"
          Write-Host "  Verdict: $verdict"
          Write-Host "  MUST failures: $mustFailCount"
          Write-Host "  Exit code: $exitCode"
          
          # Exit with same code as validation script
          exit $exitCode

      - name: Upload validation results
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: validation-${{ steps.validate.outputs.artifact-name }}
          path: validation-results/
          retention-days: 1

# Aggregate results and post comment

  aggregate:
    name: Aggregate Results
    # ADR-025: ARM runner for cost optimization (37.5% savings vs x64)
    runs-on: ubuntu-24.04-arm
    timeout-minutes: 10
    needs: [detect-changes, validate]
    if: needs.detect-changes.outputs.has_sessions == 'true'

    outputs:
      final-verdict: ${{ steps.aggregate.outputs.final_verdict }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5

      - name: Download all validation artifacts
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093
        with:
          pattern: validation-*
          path: validation-results
          merge-multiple: true

      - name: Aggregate Verdicts
        id: aggregate
        shell: pwsh -NoProfile -Command "& '{0}'"
        run: |
          Import-Module "$env:GITHUB_WORKSPACE/.github/scripts/AIReviewCommon.psm1" -Force

          $overallVerdict = "PASS"
          $totalMustFailures = 0

          # Process all verdict files
          $verdictFiles = Get-ChildItem -Path "validation-results/*-verdict.txt" -ErrorAction SilentlyContinue
          foreach ($verdictFile in $verdictFiles) {
            $verdict = Get-Content $verdictFile.FullName -Raw
            $verdict = $verdict.Trim()
            Write-Log "Found verdict: $verdict from $($verdictFile.Name)"

            if ($verdict -in 'CRITICAL_FAIL', 'REJECTED', 'NON_COMPLIANT') {
              $overallVerdict = "CRITICAL_FAIL"
            } elseif ($verdict -eq 'WARN' -and $overallVerdict -eq 'PASS') {
              $overallVerdict = "WARN"
            }
          }

          # Count MUST failures
          $mustFiles = Get-ChildItem -Path "validation-results/*-must-failures.txt" -ErrorAction SilentlyContinue
          foreach ($mustFile in $mustFiles) {
            $content = (Get-Content $mustFile.FullName -Raw -ErrorAction SilentlyContinue).Trim()
            # Handle potential multi-value strings from race conditions
            if ($content -match '^(\d+)') {
              $count = [int]$Matches[1]
              $totalMustFailures += $count
            }
          }

          if ($totalMustFailures -gt 0) {
            $overallVerdict = "CRITICAL_FAIL"
          }

          "final_verdict=$overallVerdict" >> $env:GITHUB_OUTPUT
          "must_failures=$totalMustFailures" >> $env:GITHUB_OUTPUT

          Write-Log "Final verdict: $overallVerdict (MUST failures: $totalMustFailures)"

      - name: Generate Compliance Report
        id: report
        shell: pwsh -NoProfile -Command "& '{0}'"
        env:
          OVERALL_VERDICT: ${{ steps.aggregate.outputs.final_verdict }}
          MUST_FAILURES: ${{ steps.aggregate.outputs.must_failures }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          SERVER_URL: ${{ github.server_url }}
          RUN_ID: ${{ github.run_id }}
        run: |
          Import-Module "$env:GITHUB_WORKSPACE/.github/scripts/AIReviewCommon.psm1" -Force

          $reportDir = Initialize-AIReview
          $reportFile = Join-Path $reportDir "session-compliance-report.md"
          $alertType = Get-VerdictAlertType -Verdict $env:OVERALL_VERDICT
          $finalEmoji = Get-VerdictEmoji -Verdict $env:OVERALL_VERDICT

          # Build verdict message
          $verdictMsg = if ([int]$env:MUST_FAILURES -gt 0) {
            "$($env:MUST_FAILURES) MUST requirement(s) not met. These must be addressed before merge."
          } else {
            "All session protocol requirements satisfied."
          }

          # Count files checked
          $filesChecked = (Get-ChildItem -Path "validation-results/*-verdict.txt" -ErrorAction SilentlyContinue).Count

          $report = @"
          <!-- AI-SESSION-PROTOCOL -->

          ## Session Protocol Compliance Report

          > [!$alertType]
          > $finalEmoji **Overall Verdict: $($env:OVERALL_VERDICT)**
          >
          > $verdictMsg

          <details>
          <summary>What is Session Protocol?</summary>

          Session logs document agent work sessions and must comply with RFC 2119 requirements:

          - **MUST**: Required for compliance (blocking failures)
          - **SHOULD**: Recommended practices (warnings)
          - **MAY**: Optional enhancements

          See [`.agents/SESSION-PROTOCOL.md`](.agents/SESSION-PROTOCOL.md) for full specification.

          </details>

          ### Compliance Summary

          | Session File | Verdict | MUST Failures |
          |:-------------|:--------|:-------------:|
          "@

          # Add summary row for each session file
          $verdictFiles = Get-ChildItem -Path "validation-results/*-verdict.txt" -ErrorAction SilentlyContinue
          foreach ($verdictFile in $verdictFiles) {
            $fileName = $verdictFile.BaseName -replace '-verdict$', ''
            $verdict = (Get-Content $verdictFile.FullName -Raw).Trim()
            $mustFile = "validation-results/$fileName-must-failures.txt"
            $mustCount = if (Test-Path $mustFile) { (Get-Content $mustFile -Raw).Trim() } else { "0" }
            $emoji = Get-VerdictEmoji -Verdict $verdict

            $report += "`n| ``$fileName.md`` | $emoji $verdict | $mustCount |"
          }

          # Add detailed findings with expanded information
          $report += "`n`n### Detailed Validation Results`n"
          $report += "`nClick each session to see the complete validation report with specific requirement failures.`n"

          $findingsFiles = Get-ChildItem -Path "validation-results/*-findings.txt" -ErrorAction SilentlyContinue
          foreach ($findingsFile in $findingsFiles) {
            $fileName = $findingsFile.BaseName -replace '-findings$', ''
            $findings = Get-Content $findingsFile.FullName -Raw
            
            # Add direct link to the session file
            $report += "`n<details>`n<summary>ðŸ“„ $fileName</summary>`n`n"
            $report += $findings
            $report += "`n</details>`n"
          }

          # Add footer with improved messaging
          $report += @"

          ---

          <details>
          <summary>âœ¨ Zero-Token Validation</summary>

          This validation uses deterministic PowerShell script analysis instead of AI:

          - âœ… **Zero tokens consumed** (previously 300K-900K per debug cycle)
          - âœ… **Instant feedback** - see exact failures in this summary
          - âœ… **No artifact downloads** needed to diagnose issues
          - âœ… **10x-100x faster** debugging

          Powered by [`Validate-SessionProtocol.ps1`](../../scripts/Validate-SessionProtocol.ps1)

          </details>

          <details>
          <summary>ðŸ“Š Run Details</summary>

          | Property | Value |
          |:---------|:------|
          | **Run ID** | [$($env:RUN_ID)]($($env:SERVER_URL)/$($env:GITHUB_REPOSITORY)/actions/runs/$($env:RUN_ID)) |
          | **Files Checked** | $filesChecked |
          | **Validation Method** | Deterministic script analysis |

          </details>

          <sub>Powered by [Session Protocol Validator](https://github.com/$($env:GITHUB_REPOSITORY)) workflow</sub>
          "@

          $report | Set-Content $reportFile -Encoding UTF8
          "report_file=$reportFile" >> $env:GITHUB_OUTPUT

      - name: Post PR Comment
        shell: pwsh -NoProfile -Command "& '{0}'"
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          REPORT_FILE: ${{ steps.report.outputs.report_file }}
        run: |
          # Use GitHub skill script for idempotent comment posting
          # PRs are issues in GitHub API, so we use Post-IssueComment with marker
          & .claude/skills/github/scripts/issue/Post-IssueComment.ps1 `
            -Issue $env:PR_NUMBER `
            -BodyFile $env:REPORT_FILE `
            -Marker "AI-SESSION-PROTOCOL"

      - name: Set Job Summary
        shell: pwsh -NoProfile -Command "& '{0}'"
        env:
          REPORT_FILE: ${{ steps.report.outputs.report_file }}
        run: |
          Get-Content $env:REPORT_FILE | Add-Content $env:GITHUB_STEP_SUMMARY

      - name: Enforce MUST Requirements
        shell: pwsh -NoProfile -Command "& '{0}'"
        env:
          MUST_FAILURES: ${{ steps.aggregate.outputs.must_failures }}
          FINAL_VERDICT: ${{ steps.aggregate.outputs.final_verdict }}
        run: |
          if ($env:FINAL_VERDICT -eq 'CRITICAL_FAIL' -or [int]$env:MUST_FAILURES -gt 0) {
            Write-Output "::error::Session protocol validation failed: $($env:MUST_FAILURES) MUST requirement(s) not met"
            exit 1
          }

          Write-Output "Session protocol validation passed"
