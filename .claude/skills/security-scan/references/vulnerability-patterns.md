# Vulnerability Pattern Reference

This document provides detailed information about the vulnerability patterns detected by the security-scan skill.

## CWE-22: Improper Limitation of a Pathname to a Restricted Directory (Path Traversal)

### Overview

Path traversal vulnerabilities occur when user input is used to construct file paths without proper validation. Attackers can use sequences like `../` to escape intended directories and access arbitrary files.

**Impact**: Unauthorized file read, write, or deletion. Can lead to configuration exposure, source code theft, or system compromise.

**CVSS**: Typically 7.5-9.8 (High to Critical)

### Detection Patterns

#### Python

| Pattern | Risk | Example |
|---------|------|---------|
| `os.path.join(base, user_input)` | HIGH | Attacker passes `../../../etc/passwd` |
| `open(user_path)` | HIGH | Direct file open without validation |
| `Path(user_input)` | HIGH | pathlib without containment check |
| `shutil.copy/move/rmtree` with user path | HIGH | File operations on attacker-controlled paths |

**Safe Alternatives**:

```python
import os
from pathlib import Path

def safe_path_join(base_dir: str, user_input: str) -> str:
    """Safely join paths with containment validation."""
    # Normalize and resolve
    base = Path(base_dir).resolve()
    full_path = (base / user_input).resolve()

    # Containment check
    if not str(full_path).startswith(str(base)):
        raise ValueError("Path traversal detected")

    return str(full_path)
```

#### PowerShell

| Pattern | Risk | Example |
|---------|------|---------|
| `Join-Path $base $userInput` | HIGH | Path joining without validation |
| `Get-Content $userPath` | HIGH | File read with user path |
| `. $userScript` | CRITICAL | Dot-sourcing user-provided script |

**Safe Alternatives**:

```powershell
function Get-SafePath {
    param(
        [string]$BaseDir,
        [string]$UserInput
    )

    # Resolve full paths
    $base = (Resolve-Path $BaseDir).Path
    $full = (Join-Path $base $UserInput | Resolve-Path -ErrorAction SilentlyContinue).Path

    # Containment check
    if (-not $full.StartsWith($base)) {
        throw "Path traversal detected"
    }

    return $full
}
```

#### Bash

| Pattern | Risk | Example |
|---------|------|---------|
| `cat "$user_path"` | HIGH | File read with user path |
| `source "$user_script"` | CRITICAL | Sourcing user-provided script |
| `rm -rf "$user_path"` | CRITICAL | Deletion with user path |

**Safe Alternatives**:

```bash
safe_path() {
    local base_dir="$1"
    local user_input="$2"

    # Resolve and check
    local full_path
    full_path=$(realpath -m "${base_dir}/${user_input}")

    # Containment check
    case "$full_path" in
        "${base_dir}"*)
            echo "$full_path"
            ;;
        *)
            echo "Path traversal detected" >&2
            return 1
            ;;
    esac
}
```

#### C #

| Pattern | Risk | Example |
|---------|------|---------|
| `Path.Combine(base, userInput)` | HIGH | Path combination without validation |
| `File.ReadAllText(userPath)` | HIGH | File read with user path |
| `new FileStream(userPath)` | HIGH | Stream creation with user path |

**Safe Alternatives**:

```csharp
public static string SafePathCombine(string baseDir, string userInput)
{
    var basePath = Path.GetFullPath(baseDir);
    var fullPath = Path.GetFullPath(Path.Combine(basePath, userInput));

    if (!fullPath.StartsWith(basePath, StringComparison.OrdinalIgnoreCase))
    {
        throw new SecurityException("Path traversal detected");
    }

    return fullPath;
}
```

---

## CWE-78: Improper Neutralization of Special Elements used in an OS Command (Command Injection)

### Overview

Command injection occurs when user input is incorporated into OS commands without proper sanitization. Attackers can inject additional commands using shell metacharacters.

**Impact**: Arbitrary command execution with the privileges of the application. Can lead to complete system compromise.

**CVSS**: Typically 9.8 (Critical)

### Detection Patterns

#### Python

| Pattern | Risk | Example |
|---------|------|---------|
| Subprocess with f-string command | CRITICAL | f-string in command |
| Subprocess with shell=True | HIGH | Shell interpretation enabled |
| String concatenation in subprocess | CRITICAL | String concatenation in command |

**Safe Alternatives**:

```python
import subprocess
import shlex

# SAFE: Use list form
subprocess.run(["git", "checkout", branch], check=True)

# If shell features needed, use shlex.quote for escaping
```

#### PowerShell

| Pattern | Risk | Example |
|---------|------|---------|
| Invoke-Expression with interpolation | CRITICAL | Variable interpolation in IEX |
| Call operator with user command | HIGH | & operator with user command |
| Start-Process with unvalidated args | HIGH | Unvalidated arguments |

**Safe Alternatives**:

```powershell
# SAFE: Direct cmdlet invocation
& git checkout $branch

# SAFE: Validated command
$allowedCommands = @('status', 'log', 'branch')
if ($userCommand -in $allowedCommands) {
    & git $userCommand
}
```

#### Bash

| Pattern | Risk | Example |
|---------|------|---------|
| Command substitution with user data | CRITICAL | Command substitution |
| Unquoted variable expansion | MEDIUM | Word splitting vulnerability |

**Safe Alternatives**:

```bash
# SAFE: Validate against allowlist
case "$user_command" in
    status|log|branch)
        git "$user_command"
        ;;
    *)
        echo "Invalid command" >&2
        exit 1
        ;;
esac

# SAFE: Always quote variables
echo "$user_input"
```

#### C #

| Pattern | Risk | Example |
|---------|------|---------|
| Process.Start with user command | HIGH | User-controlled process |
| Interpolated ProcessStartInfo args | HIGH | Interpolated arguments |

**Safe Alternatives**:

```csharp
// SAFE: Use ProcessStartInfo with explicit arguments
var psi = new ProcessStartInfo
{
    FileName = "git",
    Arguments = EscapeArgument(branch),
    UseShellExecute = false,
    RedirectStandardOutput = true
};

private static string EscapeArgument(string arg)
{
    // Validate and escape argument
    if (arg.Contains("\"") || arg.Contains("'") || arg.Contains(";"))
    {
        throw new ArgumentException("Invalid characters in argument");
    }
    return $"\"{arg}\"";
}
```

---

## References

- [CWE-22: Path Traversal](https://cwe.mitre.org/data/definitions/22.html)
- [CWE-78: OS Command Injection](https://cwe.mitre.org/data/definitions/78.html)
- [OWASP Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal)
- [OWASP Command Injection](https://owasp.org/www-community/attacks/Command_Injection)
- [Path Traversal Research (2025)](https://arxiv.org/abs/2505.20186)
