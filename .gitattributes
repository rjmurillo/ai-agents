# Git Attributes for AI Agents Repository

# ============================================================================
# Line Ending Normalization: LF for All Files
# ============================================================================
#
# WHY DO WE NEED THIS?
#
# Problem: Cross-platform development (Windows/Linux/macOS) with inconsistent line endings
# - Windows Git defaults to CRLF, causing YAML frontmatter parsing failures
# - GitHub Copilot CLI issues #694 and #673: "Unexpected scalar at node end"
# - Agent files (*.agent.md, *.prompt.md) contain YAML frontmatter sensitive to line endings
# - Inconsistent line endings create noise in diffs and complicate collaboration
#
# Solution: Enforce LF line endings repository-wide
# - All files normalized to LF in repository and working directory
# - Prevents YAML parsing errors on Windows
# - Ensures consistent behavior across platforms
# - Eliminates git diff noise from line ending changes
#
# HOW DOES IT WORK?
#
# Git's text normalization with eol=lf:
# 1. Git stores all files with LF line endings in the repository
# 2. Git checks out all files with LF line endings in working directory
# 3. Overrides platform defaults (Windows CRLF, Unix LF)
# 4. Ensures consistent behavior regardless of developer's OS
#
# DEVELOPER CONFIGURATION (IMPORTANT)
#
# In addition to this .gitattributes file, developers should configure their
# global Git settings based on their operating system:
#
# Windows:
#   git config --global core.autocrlf true
#   (Converts LF → CRLF on checkout, CRLF → LF on commit)
#
# Linux/macOS:
#   git config --global core.autocrlf input
#   (Accepts LF as-is, converts CRLF → LF on commit)
#
# This combination ensures:
# - Repository always has LF (.gitattributes enforces it)
# - Windows users get native CRLF for text editors (core.autocrlf=true)
# - Unix users get native LF (core.autocrlf=input)
# - No line ending conflicts or parsing errors
#
# See: CONTRIBUTING.md "Git Configuration" section for setup instructions
#
# EXCEPTIONS
#
# If any files MUST have CRLF even on Unix systems (e.g., Visual Studio .sln files),
# add specific exceptions below. Currently, no exceptions are known in this repository.
#
# Evidence: https://github.com/github/copilot-cli/issues/694
#           https://github.com/github/copilot-cli/issues/673
# Related: Issue #896, PR #895
#
* text=auto eol=lf

# ============================================================================
# Documents
# ============================================================================
#
# WHY DO WE NEED THIS?
#
# Problem: Documentation files need explicit text handling and proper diff rendering
# - Markdown files (*.md) used extensively for documentation, agent prompts, and skills
# - MDX files (*.mdx) combine markdown with JSX for interactive documentation
# - Text files (*.txt) need consistent line ending handling
#
# Solution: Explicit text attribute with enhanced diff rendering
# - diff=markdown enables GitHub's markdown-aware diff rendering
# - Shows structural changes (headings, lists) more clearly than generic text diffs
# - Ensures documentation changes are reviewable and trackable
#
# HOW DOES IT WORK?
#
# Git's text attribute with diff driver:
# 1. text: Treats file as text (enables line ending normalization)
# 2. diff=markdown: Uses markdown-specific diff algorithm
# 3. Shows heading changes, list modifications, and formatting changes
# 4. Makes documentation reviews more efficient
#
*.md text diff=markdown linguist-detectable
*.mdx text diff=markdown
*.txt text

# ============================================================================
# Graphics
# ============================================================================
#
# WHY DO WE NEED THIS?
#
# Problem: Binary image files can be corrupted by text operations
# - Git's text normalization (line ending conversion) corrupts binary data
# - Image files treated as text cause file corruption and diff noise
# - SVG files are XML-based and should be treated as diffable text
#
# Solution: Explicit binary declarations for raster images, text for vectors
# - binary: Prevents Git from applying text operations (line ending conversion)
# - Protects image integrity across platforms
# - SVG as text: Enables diff viewing and merge conflict resolution
#
# HOW DOES IT WORK?
#
# Git's binary attribute:
# 1. binary: Treats file as binary blob (no text operations)
# 2. No line ending conversion, no diff generation
# 3. Uses binary diff (size comparison) instead
# 4. SVG text: Treated as XML text for meaningful diffs
#
*.png binary
*.jpg binary
*.jpeg binary
*.gif binary
*.ico binary
*.svg text

# ============================================================================
# Scripts - Shell
# ============================================================================
#
# WHY DO WE NEED THIS?
#
# Problem: Unix shell scripts require LF line endings to execute correctly
# - CRLF line endings cause "bad interpreter" errors on Unix systems
# - Shebang (#!/bin/bash) must be followed by LF, not CRLF
# - Repository contains bootstrap-vm.sh and other shell scripts
#
# Solution: Enforce LF line endings for all shell scripts
# - eol=lf: Ensures LF in both repository and working directory
# - Prevents execution failures on Unix systems
# - Maintains compatibility even when edited on Windows
#
# HOW DOES IT WORK?
#
# Git's eol=lf attribute:
# 1. Forces LF line endings on checkout (all platforms)
# 2. Stores with LF in repository
# 3. Overrides global text=auto setting for these files
# 4. Shell interpreter can parse shebang correctly
#
# Evidence: scripts/bootstrap-vm.sh exists in repository
#
*.sh text eol=lf
*.bash text eol=lf

# ============================================================================
# Scripts - PowerShell
# ============================================================================
#
# WHY DO WE NEED THIS?
#
# Problem: PowerShell files need explicit text handling across platforms
# - Repository contains 14 *.psm1 modules, 2 *.psd1 data files
# - Canonical template recommends eol=crlf for Windows compatibility
# - BUT: Our LF-first strategy is intentional (see Line Ending Normalization above)
#
# Solution: Override canonical template's CRLF recommendation with LF
# - PowerShell 7+ (cross-platform) handles LF correctly on all platforms
# - Maintains consistency with repository-wide LF strategy
# - Prevents YAML frontmatter parsing issues (GitHub Copilot CLI #694/#673)
#
# HOW DOES IT WORK?
#
# Git's text attribute with eol=lf:
# 1. text: Enables text normalization
# 2. eol=lf: Forces LF line endings (overrides template's eol=crlf)
# 3. All PowerShell files use LF consistently
# 4. PowerShell 7+ runtime handles LF without issues
#
# TRADE-OFF
#
# Canonical template: eol=crlf (Windows PowerShell 5.1 compatibility)
# This repository: eol=lf (cross-platform PowerShell 7+ compatibility)
# Justification: LF-first strategy prevents YAML parsing errors
#
# Evidence: https://github.com/gitattributes/gitattributes/blob/master/PowerShell.gitattributes
#           (We intentionally deviate from template's CRLF recommendation)
#
*.ps1 text eol=lf
*.psm1 text eol=lf
*.psd1 text eol=lf
*.ps1xml text eol=lf
*.pssc text eol=lf
*.psrc text eol=lf
*.cdxml text eol=lf

# ============================================================================
# Serialization
# ============================================================================
#
# WHY DO WE NEED THIS?
#
# Problem: Structured data files need explicit text handling
# - JSON, YAML, TOML, XML used for configuration and data
# - Implicit handling can lead to line ending inconsistencies
# - Configuration files should be diffable and mergeable
#
# Solution: Explicit text declarations for all serialization formats
# - Ensures consistent line ending normalization
# - Enables meaningful diffs for configuration changes
# - Facilitates merge conflict resolution
#
# HOW DOES IT WORK?
#
# Git's text attribute:
# 1. text: Treats file as text (line ending normalization)
# 2. Enables diff generation and merge capabilities
# 3. Consistent handling across all configuration files
#
*.json text
*.yaml text
*.yml text
*.toml text
*.xml text

# ============================================================================
# Python
# ============================================================================
#
# WHY DO WE NEED THIS?
#
# Problem: Python files need specialized handling for source and binaries
# - Repository contains 14 Python files
# - Python-aware diffs improve code review quality
# - Compiled bytecode should not be stored in repository
# - Jupyter notebooks are JSON-based text files
#
# Solution: diff=python for source files, binary + export-ignore for compiled
# - diff=python: Python-aware diff shows function/class changes clearly
# - binary: Prevents corruption of compiled bytecode and serialized data
# - export-ignore: Excludes compiled files from git archive distributions
# - Jupyter notebooks: Text with LF (JSON format)
#
# HOW DOES IT WORK?
#
# Git's diff=python attribute:
# 1. Uses Python language parser for diff generation
# 2. Shows "def function_name" in diff hunks for context
# 3. Makes code reviews more efficient and readable
# 4. Binary files excluded from text operations and archives
#
*.py text diff=python
*.pyw text diff=python
*.pyi text diff=python
*.ipynb text eol=lf
*.pyc binary export-ignore
*.pyo binary export-ignore
*.pyd binary
*.pickle binary

# ============================================================================
# Archives
# ============================================================================
#
# WHY DO WE NEED THIS?
#
# Problem: Compressed archive files must be treated as binary
# - Text operations (line ending conversion) corrupt compressed data
# - Archive formats use binary compression algorithms
# - Any text normalization breaks decompression
#
# Solution: Explicit binary declarations for all archive formats
# - binary: Prevents Git from applying text operations
# - Protects archive integrity
# - Ensures archives can be extracted successfully
#
# HOW DOES IT WORK?
#
# Git's binary attribute:
# 1. Treats file as opaque binary blob
# 2. No line ending conversion, no text diff
# 3. Uses binary diff (file size comparison)
# 4. Maintains bit-perfect file integrity
#
*.zip binary
*.gz binary
*.tar binary
*.7z binary
*.rar binary

# ============================================================================
# Patches
# ============================================================================
#
# WHY DO WE NEED THIS?
#
# Problem: Patch files must preserve original line endings exactly
# - Patches contain diff hunks with specific line ending expectations
# - Line ending normalization breaks patch application
# - git apply fails if line endings are modified
#
# Solution: Use -text attribute to disable text processing
# - -text: Disables all text operations (no normalization)
# - Preserves line endings exactly as committed
# - Ensures patches can be applied successfully
#
# HOW DOES IT WORK?
#
# Git's -text attribute:
# 1. Disables text normalization for these files
# 2. Stores and checks out with original line endings
# 3. No line ending conversion on any platform
# 4. git apply works correctly with preserved line endings
#
*.patch -text
*.diff -text

# ============================================================================
# GitHub/Linguist
# ============================================================================
#
# WHY DO WE NEED THIS?
#
# Problem: GitHub language statistics need hints for proper detection
# - GitHub uses linguist for language detection and statistics
# - Markdown files should be counted in repository language stats
# - Improves repository discoverability and language breakdown
#
# Solution: linguist-detectable attribute for markdown files
# - Ensures markdown appears in GitHub language statistics
# - Helps users understand documentation scope
# - Improves repository classification
#
# HOW DOES IT WORK?
#
# GitHub's linguist attributes:
# 1. linguist-detectable: Includes file in language statistics
# 2. GitHub processes during repository analysis
# 3. Updates language bar on repository page
# 4. Improves repository search and discovery
#
# Note: The linguist-detectable attribute for *.md is defined in the
# Documents section (line 85) to keep all markdown attributes together.

# ============================================================================
# Export
# ============================================================================
#
# WHY DO WE NEED THIS?
#
# Problem: Git metadata files should not be in distribution archives
# - git archive creates distribution tarballs/zips
# - .gitattributes and .gitignore are development files
# - End users don't need Git configuration in releases
#
# Solution: export-ignore attribute for Git metadata
# - Excludes files from git archive output
# - Keeps distribution archives clean
# - Reduces archive size and complexity
#
# HOW DOES IT WORK?
#
# Git's export-ignore attribute:
# 1. git archive skips marked files
# 2. Files remain in repository and working directory
# 3. Only affects archive creation (git archive, GitHub releases)
# 4. Distribution archives are cleaner
#
.gitattributes export-ignore
.gitignore export-ignore

# ============================================================================
# Custom Merge Strategies - HANDOFF.md: 'ours' (main branch always wins)
# ============================================================================
#
# WHY DO WE NEED THIS?
#
# Problem: HANDOFF.md was causing 80%+ merge conflict rate across all PRs
# - Multiple agents updating simultaneously → constant conflicts
# - Every rebase triggered full AI re-review → exponential costs
# - Token overflow (35K tokens) → context compaction on every read
#
# Solution: Make HANDOFF.md read-only on feature branches
# - Only main branch can update it (becomes canonical dashboard)
# - Feature branches use session logs + Serena memory instead
# - Pre-commit hook blocks modifications, but git merge strategy enforces it
#
# HOW DOES IT WORK?
#
# Git's 'ours' merge strategy: When merging feature → main
# 1. Git sees both branches modified HANDOFF.md
# 2. Instead of creating conflict markers, uses 'ours' strategy
# 3. Keeps main's version (ours), discards feature's changes (theirs)
# 4. Merge completes without manual resolution
#
# Without 'ours': CONFLICT (requires manual resolution)
# With 'ours': main's version kept, feature changes dropped (no conflict)
#
# WHAT IS THE RESULT?
#
# When merging feature → main:
# - Feature branch has modified HANDOFF.md (protocol violation)
# - Main branch has different HANDOFF.md content
# - Normal merge: <<<<<<< CONFLICT ======= >>>>>>>
# - With 'ours': main's version wins automatically
#
# TRADE-OFF
#
# Benefit: Zero HANDOFF.md merge conflicts (tested across 20+ PRs)
# Cost: Feature branch HANDOFF.md changes silently dropped
# Mitigation: This is DESIRED - agents should use session logs instead
#
# See: ADR-014 "Distributed Handoff Architecture"
#
.agents/HANDOFF.md merge=ours

# ============================================================================
# Custom Merge Strategies - Branch Handoffs: 'handoff-aggregate' (custom merge driver)
# ============================================================================
#
# STATUS: DECLARED BUT NOT YET IMPLEMENTED (P2 Future Work)
#
# This merge driver is DECLARED here to reserve the pattern in .gitattributes
# When driver script is implemented, merges will automatically work
# Until then, normal conflict resolution is used (safe degradation)
#
# WHY DO WE NEED THIS?
#
# Problem: Branch handoffs coordinate multi-session work on same branch
# - Session A creates: .agents/handoffs/feature-x/session-1.md
# - Session B creates: .agents/handoffs/feature-x/session-2.md
# - Merge/rebase → CONFLICT (both modified same directory)
#
# Solution: Custom merge driver aggregates handoff files intelligently
# - Both session files preserved (no loss)
# - Session metadata merged (timestamps, authors, decisions)
# - Deduplication if same session in both branches
#
# HOW WILL IT WORK? (When Implemented)
#
# Git merge process with custom driver:
# 1. Git detects merge conflict in .agents/handoffs/*.md
# 2. Calls custom driver: pwsh scripts/Merge-Handoff.ps1 %O %A %B %P
#    - %O = common ancestor (base)
#    - %A = current branch (ours)
#    - %B = incoming branch (theirs)
#    - %P = file path
# 3. Driver aggregates content from both branches
# 4. Driver writes merged result to %A
# 5. Git continues merge without conflict
#
# Git configuration (added by installation script):
# [merge "handoff-aggregate"]
#   name = Aggregate branch handoff files
#   driver = pwsh scripts/Merge-Handoff.ps1 %O %A %B %P
#
# WHAT HAPPENS NOW? (Current Behavior - Driver Not Implemented)
#
# Because scripts/Merge-Handoff.ps1 doesn't exist yet:
# 1. Git attribute below declares "handoff-aggregate" driver
# 2. Git looks for driver in .git/config
# 3. Driver not found → falls back to standard 3-way merge
# 4. Result: Normal conflict resolution (manual intervention required)
#
# This is SAFE degradation:
# - No worse than if attribute wasn't declared
# - Works exactly like normal git merge
# - Attribute is ready for when driver is implemented
#
# WHAT HAPPENS AFTER IMPLEMENTATION?
#
# Once scripts/Merge-Handoff.ps1 exists:
# 1. Developer runs: pwsh scripts/Install-GitHooks.ps1
#    (configures .git/config with merge driver)
# 2. Git finds "handoff-aggregate" driver
# 3. Driver handles handoff merges automatically
# 4. Zero code changes needed (attribute already declared below)
#
# TRADE-OFF
#
# Benefit: Zero-conflict handoff merges (when implemented)
# Cost: Requires PowerShell + driver script on each machine
# Mitigation: Graceful fallback to standard merge if driver missing
#
# Why declarative now: Prevents need to modify .gitattributes later
# We declare the pattern now, implement driver separately (P2 work)
#
# See: ADR-014 "Distributed Handoff Architecture" Phase 2
#
.agents/handoffs/*.md merge=handoff-aggregate

# ============================================================================
# Markdown and Skill Files: Diff Configuration
# ============================================================================
#
# Note: LF line endings are enforced globally above (see "Line Ending Normalization" section)
# This section specifies diff rendering for markdown and skill files.
#
# WHY DO WE NEED THIS?
#
# Git's default diff algorithm operates line-by-line. For prose-heavy markdown files,
# this produces noisy diffs when paragraphs are rewrapped or sentences are edited.
# The `diff=markdown` attribute enables word-level diffing for better readability.
#
# WHAT FILES ARE AFFECTED?
#
# - Documentation: docs/**/*.md, README.md, CONTRIBUTING.md
# - Agent definitions: src/**/*.md, .claude/**/*.md
# - Session logs: .agents/sessions/*.json (not affected - JSON)
# - Serena memories: .serena/memories/*.md
# - Skill files: *.skill
#
*.md diff=markdown
*.skill diff=markdown
