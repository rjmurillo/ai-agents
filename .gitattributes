# Git Attributes for AI Agents Repository

# ============================================================================
# Line Ending Normalization: LF for All Files
# ============================================================================
#
# WHY DO WE NEED THIS?
#
# Problem: Cross-platform development (Windows/Linux/macOS) with inconsistent line endings
# - Windows Git defaults to CRLF, causing YAML frontmatter parsing failures
# - GitHub Copilot CLI issues #694 and #673: "Unexpected scalar at node end"
# - Agent files (*.agent.md, *.prompt.md) contain YAML frontmatter sensitive to line endings
# - Inconsistent line endings create noise in diffs and complicate collaboration
#
# Solution: Enforce LF line endings repository-wide
# - All files normalized to LF in repository and working directory
# - Prevents YAML parsing errors on Windows
# - Ensures consistent behavior across platforms
# - Eliminates git diff noise from line ending changes
#
# HOW DOES IT WORK?
#
# Git's text normalization with eol=lf:
# 1. Git stores all files with LF line endings in the repository
# 2. Git checks out all files with LF line endings in working directory
# 3. Overrides platform defaults (Windows CRLF, Unix LF)
# 4. Ensures consistent behavior regardless of developer's OS
#
# DEVELOPER CONFIGURATION (IMPORTANT)
#
# In addition to this .gitattributes file, developers should configure their
# global Git settings based on their operating system:
#
# Windows:
#   git config --global core.autocrlf true
#   (Converts LF → CRLF on checkout, CRLF → LF on commit)
#
# Linux/macOS:
#   git config --global core.autocrlf input
#   (Accepts LF as-is, converts CRLF → LF on commit)
#
# This combination ensures:
# - Repository always has LF (.gitattributes enforces it)
# - Windows users get native CRLF for text editors (core.autocrlf=true)
# - Unix users get native LF (core.autocrlf=input)
# - No line ending conflicts or parsing errors
#
# See: CONTRIBUTING.md "Git Configuration" section for setup instructions
#
# EXCEPTIONS
#
# If any files MUST have CRLF even on Unix systems (e.g., Visual Studio .sln files),
# add specific exceptions below. Currently, no exceptions are known in this repository.
#
# Evidence: https://github.com/github/copilot-cli/issues/694
#           https://github.com/github/copilot-cli/issues/673
# Related: Issue #896, PR #895
#
* text=auto eol=lf

# ============================================================================
# HANDOFF.md Merge Strategy: 'ours' (main branch always wins)
# ============================================================================
#
# WHY DO WE NEED THIS?
#
# Problem: HANDOFF.md was causing 80%+ merge conflict rate across all PRs
# - Multiple agents updating simultaneously → constant conflicts
# - Every rebase triggered full AI re-review → exponential costs
# - Token overflow (35K tokens) → context compaction on every read
#
# Solution: Make HANDOFF.md read-only on feature branches
# - Only main branch can update it (becomes canonical dashboard)
# - Feature branches use session logs + Serena memory instead
# - Pre-commit hook blocks modifications, but git merge strategy enforces it
#
# HOW DOES IT WORK?
#
# Git's 'ours' merge strategy: When merging feature → main
# 1. Git sees both branches modified HANDOFF.md
# 2. Instead of creating conflict markers, uses 'ours' strategy
# 3. Keeps main's version (ours), discards feature's changes (theirs)
# 4. Merge completes without manual resolution
#
# Without 'ours': CONFLICT (requires manual resolution)
# With 'ours': main's version kept, feature changes dropped (no conflict)
#
# WHAT IS THE RESULT?
#
# When merging feature → main:
# - Feature branch has modified HANDOFF.md (protocol violation)
# - Main branch has different HANDOFF.md content
# - Normal merge: <<<<<<< CONFLICT ======= >>>>>>>
# - With 'ours': main's version wins automatically
#
# TRADE-OFF
#
# Benefit: Zero HANDOFF.md merge conflicts (tested across 20+ PRs)
# Cost: Feature branch HANDOFF.md changes silently dropped
# Mitigation: This is DESIRED - agents should use session logs instead
#
# See: ADR-014 "Distributed Handoff Architecture"
#
.agents/HANDOFF.md merge=ours

# ============================================================================
# Branch Handoffs: 'handoff-aggregate' (custom merge driver)
# ============================================================================
#
# STATUS: DECLARED BUT NOT YET IMPLEMENTED (P2 Future Work)
#
# This merge driver is DECLARED here to reserve the pattern in .gitattributes
# When driver script is implemented, merges will automatically work
# Until then, normal conflict resolution is used (safe degradation)
#
# WHY DO WE NEED THIS?
#
# Problem: Branch handoffs coordinate multi-session work on same branch
# - Session A creates: .agents/handoffs/feature-x/session-1.md
# - Session B creates: .agents/handoffs/feature-x/session-2.md
# - Merge/rebase → CONFLICT (both modified same directory)
#
# Solution: Custom merge driver aggregates handoff files intelligently
# - Both session files preserved (no loss)
# - Session metadata merged (timestamps, authors, decisions)
# - Deduplication if same session in both branches
#
# HOW WILL IT WORK? (When Implemented)
#
# Git merge process with custom driver:
# 1. Git detects merge conflict in .agents/handoffs/*.md
# 2. Calls custom driver: pwsh scripts/Merge-Handoff.ps1 %O %A %B %P
#    - %O = common ancestor (base)
#    - %A = current branch (ours)
#    - %B = incoming branch (theirs)
#    - %P = file path
# 3. Driver aggregates content from both branches
# 4. Driver writes merged result to %A
# 5. Git continues merge without conflict
#
# Git configuration (added by installation script):
# [merge "handoff-aggregate"]
#   name = Aggregate branch handoff files
#   driver = pwsh scripts/Merge-Handoff.ps1 %O %A %B %P
#
# WHAT HAPPENS NOW? (Current Behavior - Driver Not Implemented)
#
# Because scripts/Merge-Handoff.ps1 doesn't exist yet:
# 1. Git attribute below declares "handoff-aggregate" driver
# 2. Git looks for driver in .git/config
# 3. Driver not found → falls back to standard 3-way merge
# 4. Result: Normal conflict resolution (manual intervention required)
#
# This is SAFE degradation:
# - No worse than if attribute wasn't declared
# - Works exactly like normal git merge
# - Attribute is ready for when driver is implemented
#
# WHAT HAPPENS AFTER IMPLEMENTATION?
#
# Once scripts/Merge-Handoff.ps1 exists:
# 1. Developer runs: pwsh scripts/Install-GitHooks.ps1
#    (configures .git/config with merge driver)
# 2. Git finds "handoff-aggregate" driver
# 3. Driver handles handoff merges automatically
# 4. Zero code changes needed (attribute already declared below)
#
# TRADE-OFF
#
# Benefit: Zero-conflict handoff merges (when implemented)
# Cost: Requires PowerShell + driver script on each machine
# Mitigation: Graceful fallback to standard merge if driver missing
#
# Why declarative now: Prevents need to modify .gitattributes later
# We declare the pattern now, implement driver separately (P2 work)
#
# See: ADR-014 "Distributed Handoff Architecture" Phase 2
#
.agents/handoffs/*.md merge=handoff-aggregate

# ============================================================================
# Markdown Files: Diff Configuration
# ============================================================================
#
# Note: LF line endings are enforced globally above (see "Line Ending Normalization" section)
# This section specifies diff rendering for markdown and skill files.
#
# WHY DO WE NEED THIS?
#
# Git's default diff algorithm operates line-by-line. For prose-heavy markdown files,
# this produces noisy diffs when paragraphs are rewrapped or sentences are edited.
# The `diff=markdown` attribute enables word-level diffing for better readability.
#
# WHAT FILES ARE AFFECTED?
#
# - Documentation: docs/**/*.md, README.md, CONTRIBUTING.md
# - Agent definitions: src/**/*.md, .claude/**/*.md
# - Session logs: .agents/sessions/*.json (not affected - JSON)
# - Serena memories: .serena/memories/*.md
# - Skill files: *.skill
#
*.md diff=markdown
*.skill diff=markdown
