#!/usr/bin/env bash
#
# Pre-commit hook for vs-code-agents repository
# AUTOMATICALLY FIXES markdown linting issues and re-stages corrected files.
#
# Linter:
#   - markdownlint-cli2 for markdown files (auto-fix enabled)
#
# To enable: git config core.hooksPath .githooks
# To bypass: git commit --no-verify (use sparingly)
#
# Environment variables:
#   SKIP_AUTOFIX=1 - Check only, don't auto-fix (CI mode)
#

set -e

# Colors for output (if terminal supports it)
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Check if we're in a terminal that supports colors
if [ ! -t 1 ]; then
    RED=''
    GREEN=''
    YELLOW=''
    CYAN=''
    NC=''
fi

echo_error() {
    echo -e "${RED}ERROR:${NC} $1"
}

echo_warning() {
    echo -e "${YELLOW}WARNING:${NC} $1"
}

echo_success() {
    echo -e "${GREEN}SUCCESS:${NC} $1"
}

echo_info() {
    echo "$1"
}

echo_action() {
    echo -e "${CYAN}FIXING:${NC} $1"
}

# Track overall exit status
EXIT_STATUS=0

# Track if any files were auto-fixed
FILES_FIXED=0

# Auto-fix mode (default: enabled)
AUTOFIX=1
if [ "${SKIP_AUTOFIX:-}" = "1" ]; then
    AUTOFIX=0
    echo_info "Auto-fix disabled (SKIP_AUTOFIX=1)"
fi

# Get repository root (LOW-001: Validate git output)
REPO_ROOT=$(git rev-parse --show-toplevel) || {
    echo_error "Failed to determine repository root"
    exit 1
}
# Validate path exists and is a directory
if [ ! -d "$REPO_ROOT" ]; then
    echo_error "Invalid repository root: $REPO_ROOT"
    exit 1
fi
cd "$REPO_ROOT"

# Get staged files (Added, Copied, Modified, Renamed - excluding Deleted)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACMR)

if [ -z "$STAGED_FILES" ]; then
    echo_info "No staged files to check."
    exit 0
fi

# Filter for markdown files only
STAGED_MD_FILES=$(echo "$STAGED_FILES" | grep -E '\.md$' || true)

#
# Markdown Linting with markdownlint-cli2
#
# Security: Uses arrays and proper quoting to prevent command injection (CRITICAL-001)
# Security: Uses while/read loop to handle filenames with spaces (HIGH-001)
# Security: Checks for symlinks to prevent TOCTOU attacks (MEDIUM-002)
# Security: Prefers local installation over npx for dependency security (HIGH-002)
#

# Function to get the markdownlint command
# HIGH-002: Check for local installation first to prevent dependency confusion
get_markdownlint_cmd() {
    if [ -x "./node_modules/.bin/markdownlint-cli2" ]; then
        echo "./node_modules/.bin/markdownlint-cli2"
        return 0
    elif command -v npx &> /dev/null; then
        echo "npx markdownlint-cli2"
        return 0
    else
        return 1
    fi
}

if [ -n "$STAGED_MD_FILES" ]; then
    echo_info "Checking markdown files..."

    # Get the markdownlint command (local preferred, npx fallback)
    if ! MARKDOWNLINT_CMD=$(get_markdownlint_cmd); then
        echo_warning "markdownlint-cli2 not available. Skipping markdown linting."
        echo_warning "Install locally: npm install --save-dev markdownlint-cli2"
        echo_warning "Or install Node.js and npm to enable npx fallback."
    else
        # CRITICAL-001: Build array safely to prevent command injection
        # Use mapfile to read newline-separated file list into array
        mapfile -t MD_FILES <<< "$STAGED_MD_FILES"

        # Validate array is not empty
        if [ ${#MD_FILES[@]} -eq 0 ]; then
            echo_info "No markdown files to process."
        else
            # First, try to auto-fix
            if [ "$AUTOFIX" = "1" ]; then
                echo_action "Auto-fixing markdown files..."
                # CRITICAL-001: Use proper array expansion with quotes and -- separator
                # LOW-002: Capture stderr to temp file for review, but don't suppress completely
                LINT_ERRORS=$(mktemp)
                # shellcheck disable=SC2086
                $MARKDOWNLINT_CMD --fix --no-globs -- "${MD_FILES[@]}" 2>"$LINT_ERRORS" || true
                # Only show errors if file is non-empty (not just benign output)
                if [ -s "$LINT_ERRORS" ]; then
                    # MEDIUM-001: Show only first few lines of errors to avoid info disclosure
                    head -5 "$LINT_ERRORS" >&2 || true
                fi
                rm -f "$LINT_ERRORS"
            fi

            # MEDIUM-001: Capture verification output for structured display
            LINT_OUTPUT=$(mktemp)
            # CRITICAL-001: Use proper array expansion with quotes and -- separator
            # shellcheck disable=SC2086
            if ! $MARKDOWNLINT_CMD --no-globs -- "${MD_FILES[@]}" >"$LINT_OUTPUT" 2>&1; then
                echo_error "Markdown linting failed (some issues cannot be auto-fixed)."
                echo_info "  Review errors below and fix manually:"
                echo ""
                # MEDIUM-001: Show structured output, limiting to prevent info disclosure
                # Filter to show only the linting errors, not system paths
                grep -E '^[^/].*:.*MD[0-9]+' "$LINT_OUTPUT" 2>/dev/null | head -20 || cat "$LINT_OUTPUT" | head -20
                echo ""
                echo_info "  Common unfixable issues:"
                echo_info "    - MD040: Add language identifier to code blocks"
                echo_info "    - MD033: Wrap generic types like ArrayPool<T> in backticks"
                rm -f "$LINT_OUTPUT"
                EXIT_STATUS=1
            else
                rm -f "$LINT_OUTPUT"
                # HIGH-001: Use while/read loop with proper IFS to handle spaces in filenames
                # MEDIUM-002: Check for symlinks to prevent TOCTOU race conditions
                while IFS= read -r file; do
                    # Skip empty lines
                    [ -z "$file" ] && continue

                    # MEDIUM-002: Reject symlinks to prevent race condition attacks
                    if [ -L "$file" ]; then
                        echo_warning "Skipping symlink: $file"
                        continue
                    fi

                    # Process regular files only
                    if [ -f "$file" ] && ! git diff --quiet -- "$file" 2>/dev/null; then
                        echo_success "Fixed: $file"
                        # Use -- to prevent filenames starting with - being treated as options
                        git add -- "$file"
                        FILES_FIXED=1
                    fi
                done <<< "$STAGED_MD_FILES"
                echo_success "Markdown files OK."
            fi
        fi
    fi
else
    echo_info "No markdown files staged. Skipping markdown linting."
fi

#
# PowerShell Script Analysis with PSScriptAnalyzer
#
# Security: Validates PowerShell scripts for syntax errors and common issues
# Security: Uses arrays and proper quoting to prevent command injection (CRITICAL-001)
# Security: Uses while/read loop to handle filenames with spaces (HIGH-001)
# Security: Checks for symlinks to prevent TOCTOU attacks (MEDIUM-002)
# Related: Session 36 retrospective, Skill-PowerShell-001, Skill-CI-001
#

# Filter for PowerShell files only
STAGED_PS_FILES=$(echo "$STAGED_FILES" | grep -E '\.(ps1|psm1)$' || true)

if [ -n "$STAGED_PS_FILES" ]; then
    echo_info "Checking PowerShell scripts with PSScriptAnalyzer..."
    
    if command -v pwsh &> /dev/null; then
        # CRITICAL-001: Build array safely to prevent command injection
        # Use mapfile to read newline-separated file list into array
        mapfile -t PS_FILES <<< "$STAGED_PS_FILES"
        
        # Validate array is not empty
        if [ ${#PS_FILES[@]} -eq 0 ]; then
            echo_info "No PowerShell files to process."
        else
            # Check if PSScriptAnalyzer module is available
            # Use -ErrorAction Stop and check for actual module output (Get-Module returns $null when not found)
            if pwsh -NoProfile -Command 'if (-not (Get-Module -ListAvailable PSScriptAnalyzer)) { exit 1 }'; then
                # MEDIUM-002: Check for symlinks to prevent TOCTOU race conditions
                # Use PS_FILES array with for loop for safe filename handling
                PS_ERRORS_FOUND=0
                
                # Use PS_FILES array populated from mapfile (line 212)
                for file in "${PS_FILES[@]}"; do
                    # Skip empty entries
                    [ -z "$file" ] && continue

                    # MEDIUM-002: Reject symlinks to prevent race condition attacks
                    if [ -L "$file" ]; then
                        echo_warning "Skipping symlink: $file"
                        continue
                    fi

                    # Process regular files only
                    if [ -f "$file" ]; then
                        # Run PSScriptAnalyzer on file, checking for Error and Warning severity
                        # Capture output for display
                        ANALYZER_OUTPUT=$(mktemp)
                        # CRITICAL-001: Pass file path via environment variable to prevent command injection
                        # Single quotes in filenames cannot escape when using $env: variable
                        if ! PSANALYZER_FILE="$file" pwsh -NoProfile -Command 'Invoke-ScriptAnalyzer -Path $env:PSANALYZER_FILE -Settings ".PSScriptAnalyzerSettings.psd1" -Severity Error,Warning | ForEach-Object { Write-Output "$($_.Severity): $($_.Message) at line $($_.Line)" }' > "$ANALYZER_OUTPUT" 2>&1; then
                            echo_error "Failed to analyze: $file"
                            cat "$ANALYZER_OUTPUT"
                            rm -f "$ANALYZER_OUTPUT"
                            EXIT_STATUS=1
                            continue
                        fi

                        # Check if there are any Error-level issues (blocking)
                        if grep -q "^Error:" "$ANALYZER_OUTPUT"; then
                            echo_error "PSScriptAnalyzer errors in: $file"
                            grep "^Error:" "$ANALYZER_OUTPUT"
                            PS_ERRORS_FOUND=1
                            EXIT_STATUS=1
                        fi

                        # Display warnings (non-blocking)
                        if grep -q "^Warning:" "$ANALYZER_OUTPUT"; then
                            echo_warning "PSScriptAnalyzer warnings in: $file"
                            grep "^Warning:" "$ANALYZER_OUTPUT"
                        fi

                        rm -f "$ANALYZER_OUTPUT"
                    fi
                done
                
                if [ $PS_ERRORS_FOUND -eq 0 ]; then
                    echo_success "PowerShell scripts OK."
                else
                    echo_error "PowerShell script analysis failed. Fix errors above before committing."
                fi
            else
                echo_warning "PSScriptAnalyzer module not available. Skipping PowerShell analysis."
                echo_warning "Install: pwsh -Command 'Install-Module -Name PSScriptAnalyzer -Scope CurrentUser -Force'"
            fi
        fi
    else
        echo_warning "PowerShell not available. Skipping PowerShell script analysis."
        echo_warning "Install: https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell"
    fi
else
    echo_info "No PowerShell files staged. Skipping PSScriptAnalyzer."
fi

#
# Planning Artifacts Validation
#
# Validates cross-document consistency in planning artifacts.
# Checks:
# - Effort estimate consistency (20% threshold)
# - Condition-to-task traceability (no orphan conditions)
#
# Related: Issue rjmurillo/ai-agents#I2, #I4 (Cross-Document Consistency)
#
PLANNING_VALIDATE_SCRIPT="$REPO_ROOT/build/scripts/Validate-PlanningArtifacts.ps1"

# Check if any planning files are staged
STAGED_PLANNING_FILES=$(echo "$STAGED_FILES" | grep -E '^\.agents/planning/.*\.md$' || true)

if [ -n "$STAGED_PLANNING_FILES" ]; then
    echo_info "Checking planning artifact consistency..."
    
    # MEDIUM-002: Reject symlinks for security
    if [ -L "$PLANNING_VALIDATE_SCRIPT" ]; then
        echo_warning "Skipping planning validation: script path is a symlink"
    elif [ -f "$PLANNING_VALIDATE_SCRIPT" ]; then
        if command -v pwsh &> /dev/null; then
            # Run validation in warning mode (don't block commits, but show issues)
            if ! pwsh -NoProfile -File "$PLANNING_VALIDATE_SCRIPT" -Path "$REPO_ROOT" 2>&1; then
                echo_warning "Planning artifact validation found issues (see above)."
                echo_info "  Consider running: pwsh build/scripts/Validate-PlanningArtifacts.ps1"
                # Non-blocking: just warn, don't fail the commit
            else
                echo_success "Planning artifacts OK."
            fi
        else
            echo_warning "PowerShell not available. Skipping planning artifact validation."
            echo_warning "Install: https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell"
        fi
    else
        echo_info "Planning validation script not found. Skipping."
    fi
else
    echo_info "No planning files staged. Skipping planning artifact validation."
fi

#
# Consistency Validation
#
# Validates cross-document consistency for agent-generated artifacts.
# Checks:
# - Scope alignment (epic vs PRD)
# - Requirement coverage (PRD to tasks)
# - Naming conventions (EPIC-NNN, ADR-NNN patterns)
# - Cross-reference validity (file existence)
#
# Related: Issue rjmurillo/ai-agents#44 (Phase 3 consistency)
#
CONSISTENCY_VALIDATE_SCRIPT="$REPO_ROOT/scripts/Validate-Consistency.ps1"

# Check if any planning files are staged that might need consistency validation
if [ -n "$STAGED_PLANNING_FILES" ]; then
    echo_info "Checking cross-document consistency..."

    # MEDIUM-002: Reject symlinks for security
    if [ -L "$CONSISTENCY_VALIDATE_SCRIPT" ]; then
        echo_warning "Skipping consistency validation: script path is a symlink"
    elif [ -f "$CONSISTENCY_VALIDATE_SCRIPT" ]; then
        if command -v pwsh &> /dev/null; then
            # Run validation - failures will be reported but won't block commits
            # Note: -CI flag ensures script returns non-zero exit code on failures
            if ! pwsh -NoProfile -File "$CONSISTENCY_VALIDATE_SCRIPT" -All -CI -Path "$REPO_ROOT" 2>&1; then
                echo_warning "Consistency validation found issues (see above)."
                echo_info "  Consider running: pwsh scripts/Validate-Consistency.ps1 -All"
                # Non-blocking: just warn, don't fail the commit
            else
                echo_success "Consistency validation OK."
            fi
        else
            echo_warning "PowerShell not available. Skipping consistency validation."
        fi
    else
        echo_info "Consistency validation script not found. Skipping."
    fi
fi

#
# MCP Configuration Sync
#
# Syncs Claude's .mcp.json to VS Code's mcp.json format when .mcp.json is staged.
# Claude uses "mcpServers" key, VS Code uses "servers" key.
# .mcp.json is the source of truth; mcp.json is auto-generated.
#
# Security: Checks for symlinks to prevent TOCTOU attacks (MEDIUM-002)
#
MCP_SYNC_SCRIPT="$REPO_ROOT/scripts/Sync-McpConfig.ps1"

# Check if .mcp.json is staged
STAGED_MCP_FILE=$(echo "$STAGED_FILES" | grep -E '^\.mcp\.json$' || true)

if [ -n "$STAGED_MCP_FILE" ]; then
    # Check if auto-fix is enabled (respects SKIP_AUTOFIX environment variable)
    if [ "$AUTOFIX" = "1" ]; then
        echo_info "Syncing MCP configuration..."

        # MEDIUM-002: Reject symlinks for security
        if [ -L "$MCP_SYNC_SCRIPT" ]; then
            echo_warning "Skipping MCP sync: script path is a symlink"
        elif [ -f "$MCP_SYNC_SCRIPT" ]; then
            if command -v pwsh &> /dev/null; then
            # Run sync script with PassThru to get sync status (returns True/False string)
            SYNC_OUTPUT=$(pwsh -NoProfile -File "$MCP_SYNC_SCRIPT" -PassThru 2>&1)
            SYNC_EXIT=$?

            if [ $SYNC_EXIT -eq 0 ]; then
                # Script succeeded - check if files were actually synced
                if echo "$SYNC_OUTPUT" | grep -q '^True$'; then
                    # MEDIUM-002: Defense-in-depth symlink check before staging
                    # (Mitigates TOCTOU race between PowerShell check and git add)
                    if [ -L "$REPO_ROOT/mcp.json" ]; then
                        echo_warning "Skipping MCP sync staging: mcp.json is a symlink"
                    else
                        # Files were synced - stage the generated file
                        git add -- "$REPO_ROOT/mcp.json"
                        echo_success "Synced: mcp.json"
                        FILES_FIXED=1
                    fi
                else
                    # Files already in sync (PassThru returned False)
                    echo_success "MCP config already in sync."
                fi
            else
                # Script failed
                echo_warning "MCP sync script failed (see above)."
                # Non-blocking: just warn, don't fail the commit
            fi
        else
            echo_warning "PowerShell not available. Skipping MCP config sync."
            echo_warning "Install: https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell"
        fi
    else
        echo_info "MCP sync script not found. Skipping."
    fi
    else
        echo_info "MCP config sync skipped (auto-fix disabled)."
    fi
fi

#
# Skill Generation (BLOCKING)
#
# Auto-generates *.skill files from canonical SKILL.md sources.
# SKILL.md is the source of truth; *.skill is auto-generated for Claude.
# Ensures generated files stay in sync with source changes.
#
# Security: Checks for symlinks to prevent TOCTOU attacks (MEDIUM-002)
# Related: Generate-Skills.ps1, ADR-005 (PowerShell-only)
#
SKILL_GEN_SCRIPT="$REPO_ROOT/build/Generate-Skills.ps1"

# Check if any SKILL.md files are staged
STAGED_SKILL_FILES=$(echo "$STAGED_FILES" | grep -E '/SKILL\.md$' || true)

if [ -n "$STAGED_SKILL_FILES" ]; then
    # Check if auto-fix is enabled (respects SKIP_AUTOFIX environment variable)
    if [ "$AUTOFIX" = "1" ]; then
        echo_info "Auto-generating skill files from SKILL.md..."

        # MEDIUM-002: Reject symlinks for security
        if [ -L "$SKILL_GEN_SCRIPT" ]; then
            echo_warning "Skipping skill generation: script path is a symlink"
        elif [ -f "$SKILL_GEN_SCRIPT" ]; then
            if command -v pwsh &> /dev/null; then
                # Run generator to update *.skill files
                if pwsh -NoProfile -File "$SKILL_GEN_SCRIPT" -Root "$REPO_ROOT" 2>&1; then
                    # Generator succeeded - check for modified *.skill files
                    # Use while/read loop with proper IFS to handle spaces in filenames
                    while IFS= read -r skill_md; do
                        [ -z "$skill_md" ] && continue

                        # Derive *.skill path from SKILL.md directory
                        skill_dir=$(dirname "$skill_md")

                        # Find all *.skill files in the same directory
                        # MEDIUM-002: Defense-in-depth symlink check before staging
                        find "$skill_dir" -maxdepth 1 -name '*.skill' -type f ! -type l 2>/dev/null | while read -r skill_file; do
                            # Check if the skill file was modified by the generator
                            if ! git diff --quiet -- "$skill_file" 2>/dev/null; then
                                echo_success "Generated: $skill_file"
                                # Use -- to prevent filenames starting with - being treated as options
                                git add -- "$skill_file"
                                FILES_FIXED=1
                            fi
                        done
                    done <<< "$STAGED_SKILL_FILES"
                    echo_success "Skill files generated."
                else
                    echo_error "Skill generation failed (see above)."
                    echo_info "  Fix SKILL.md or run manually: pwsh build/Generate-Skills.ps1"
                    EXIT_STATUS=1
                fi
            else
                echo_warning "PowerShell not available. Skipping skill generation."
                echo_warning "Install: https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell"
            fi
        else
            echo_info "Skill generation script not found. Skipping."
        fi
    else
        echo_info "Skill generation skipped (auto-fix disabled)."
        echo_info "  Run manually after commit: pwsh build/Generate-Skills.ps1"
    fi
else
    echo_info "No SKILL.md files staged. Skipping skill generation."
fi

#
# Security Detection (Non-blocking warning)
#
# Detects infrastructure and security-critical file changes
# and recommends security agent review if matches found.
#
# Security: Checks for symlinks to prevent TOCTOU attacks (MEDIUM-002)
#
SECURITY_DETECTION_SCRIPT="$REPO_ROOT/.agents/utilities/security-detection/detect_infrastructure.py"

# MEDIUM-002: Reject symlinks for security detection script
if [ -L "$SECURITY_DETECTION_SCRIPT" ]; then
    echo_warning "Skipping security detection: script path is a symlink"
elif [ -f "$SECURITY_DETECTION_SCRIPT" ]; then
    if command -v python3 &> /dev/null; then
        echo_info "Checking for security-critical file changes..."
        python3 "$SECURITY_DETECTION_SCRIPT" --git-staged || true
    elif command -v python &> /dev/null; then
        echo_info "Checking for security-critical file changes..."
        python "$SECURITY_DETECTION_SCRIPT" --git-staged || true
    fi
fi

#
# Bash Detection (BLOCKING)
#
# Enforces ADR-005: PowerShell-Only Scripting Standard
# Rejects bash usage in GitHub workflow files and script files.
# Uses pwsh (PowerShell) as the approved alternative.
#
# Security: Prevents bash code from bypassing PowerShell hardening (CWE-20/CWE-78)
# Related: ADR-005, Skill-Security-010
#

# Check staged workflow files for shell: bash
STAGED_WORKFLOW_FILES=$(echo "$STAGED_FILES" | grep -E '^\.github/(workflows|scripts)/.*\.(yml|yaml)$' || true)

if [ -n "$STAGED_WORKFLOW_FILES" ]; then
    echo_info "Checking for bash usage in workflow files (ADR-005)..."

    # SECURITY: Use mapfile to safely convert newline-separated file list to array
    # This prevents command injection via malicious filenames containing shell metacharacters
    mapfile -t WORKFLOW_FILES_ARRAY <<< "$STAGED_WORKFLOW_FILES"

    # SECURITY: Use array expansion with quotes to preserve filenames with spaces/special chars
    # Use -- separator to prevent filenames starting with - from being interpreted as options
    if git diff --cached -- "${WORKFLOW_FILES_ARRAY[@]}" | grep -E '^\+.*shell:\s*bash' > /dev/null 2>&1; then
        echo_error "Bash not allowed in workflow files (ADR-005)."
        echo_info "  Use PowerShell instead: shell: pwsh"
        echo_info "  See: .agents/architecture/ADR-005-powershell-only-scripting.md"
        EXIT_STATUS=1
    else
        echo_success "No bash usage in workflow YAML files."
    fi
fi

# Check staged script files for bash shebangs
STAGED_SCRIPT_FILES=$(echo "$STAGED_FILES" | grep -E '^\.github/scripts/.*\.(sh|bash)$' || true)

if [ -n "$STAGED_SCRIPT_FILES" ]; then
    echo_error "Bash scripts (.sh, .bash) not allowed in .github/scripts/ (ADR-005)."
    echo_info "  Use PowerShell (.ps1, .psm1) instead."
    echo_info "  See: .agents/architecture/ADR-005-powershell-only-scripting.md"
    EXIT_STATUS=1
fi

# Check for bash shebangs in any staged files under .github/scripts/
STAGED_GITHUB_SCRIPT_FILES=$(echo "$STAGED_FILES" | grep -E '^\.github/scripts/' || true)

if [ -n "$STAGED_GITHUB_SCRIPT_FILES" ]; then
    # SECURITY: Use mapfile to safely convert newline-separated file list to array
    # This prevents command injection via malicious filenames containing shell metacharacters
    mapfile -t GITHUB_SCRIPT_FILES_ARRAY <<< "$STAGED_GITHUB_SCRIPT_FILES"

    # SECURITY: Use array expansion with quotes to preserve filenames with spaces/special chars
    # Use -- separator to prevent filenames starting with - from being interpreted as options
    if git diff --cached -- "${GITHUB_SCRIPT_FILES_ARRAY[@]}" | grep -E '^\+#!.*(bin/bash|env bash)' > /dev/null 2>&1; then
        echo_error "Bash shebang not allowed in .github/scripts/ files (ADR-005)."
        echo_info "  Use PowerShell instead. Scripts should be .ps1 files."
        echo_info "  See: .agents/architecture/ADR-005-powershell-only-scripting.md"
        EXIT_STATUS=1
    fi
fi

#
# HANDOFF.md Protection (BLOCKING)
#
# Enforces ADR-014: Distributed Handoff Architecture
# HANDOFF.md is now read-only. Agents must NOT update it during sessions.
# Session context goes to:
#   1. Session logs (.agents/sessions/)
#   2. Serena memory (cross-session context)
#   3. Branch handoffs (.agents/handoffs/{branch}/)
#
# Security: Fail-closed - blocks direct HANDOFF.md modifications on feature branches
# Related: ADR-014, SESSION-PROTOCOL.md v1.4, Issue #190
#
CURRENT_BRANCH=$(git branch --show-current)
STAGED_HANDOFF=$(echo "$STAGED_FILES" | grep -E '^\.agents/HANDOFF\.md$' || true)

if [ -n "$STAGED_HANDOFF" ]; then
    # Allow HANDOFF.md updates only on main branch
    if [ "$CURRENT_BRANCH" != "main" ]; then
        echo_error "BLOCKED: HANDOFF.md is read-only on feature branches"
        echo_info "  Branch: $CURRENT_BRANCH"
        echo_info "  Protocol: Do NOT update HANDOFF.md directly"
        echo_info ""
        echo_info "Session context goes to:"
        echo_info "  1. Session log: .agents/sessions/YYYY-MM-DD-session-NN.md"
        echo_info "  2. Serena memory: Use mcp__serena__write_memory"
        echo_info "  3. Branch handoff (optional): .agents/handoffs/$CURRENT_BRANCH/"
        echo_info ""
        echo_info "See: .agents/architecture/ADR-014-distributed-handoff-architecture.md"
        echo_info "See: .agents/SESSION-PROTOCOL.md v1.4"
        EXIT_STATUS=1
    fi
fi

#
# Token Budget Validation (BLOCKING)
#
# Validates that HANDOFF.md stays within 5K token budget.
# Prevents context limit overflow that causes merge conflicts.
#
# Related: Issue #190 (HANDOFF.md merge conflicts), ADR-014
#
TOKEN_BUDGET_SCRIPT="$REPO_ROOT/scripts/Validate-TokenBudget.ps1"

if [ -n "$STAGED_HANDOFF" ]; then
    echo_info "Checking HANDOFF.md token budget..."
    
    # MEDIUM-002: Reject symlinks for security
    if [ -L "$TOKEN_BUDGET_SCRIPT" ]; then
        echo_warning "Skipping token budget validation: script path is a symlink"
    elif [ -f "$TOKEN_BUDGET_SCRIPT" ]; then
        if command -v pwsh &> /dev/null; then
            # Run token budget validation in CI mode
            if ! pwsh -NoProfile -File "$TOKEN_BUDGET_SCRIPT" -Path "$REPO_ROOT" -CI 2>&1; then
                echo_error "Token budget validation FAILED."
                echo_info "  HANDOFF.md exceeds 5K token limit."
                EXIT_STATUS=1
            else
                echo_success "Token budget validation: PASS"
            fi
        else
            echo_warning "PowerShell not available. Skipping token budget validation."
        fi
    else
        echo_info "Token budget script not found. Skipping."
    fi
fi

#
# Session End Validation (BLOCKING)
#
# Enforces Session Protocol compliance for agent sessions.
# When .agents/ files are staged (indicating an agent session), requires:
# - Session log staged under .agents/sessions/
# - Validate-SessionEnd.ps1 PASS
# - HANDOFF.md must NOT be staged (unless on main branch)
#
# Security: Fail-closed - if validation fails or cannot run, commit is blocked
# Related: SESSION-PROTOCOL.md v1.4, Skill-Protocol-002, Skill-Validation-006
#
SESSION_END_SCRIPT="$REPO_ROOT/scripts/Validate-SessionEnd.ps1"

# Check if any .agents/ files are staged (indicating an active session)
STAGED_AGENTS_FILES=$(echo "$STAGED_FILES" | grep -E '^\.agents/' || true)

if [ -n "$STAGED_AGENTS_FILES" ]; then
    echo_info "Checking Session End protocol compliance..."

    # MEDIUM-002: Reject symlinks for security
    if [ -L "$SESSION_END_SCRIPT" ]; then
        echo_error "Session End validation blocked: script path is a symlink"
        EXIT_STATUS=1
    elif [ ! -f "$SESSION_END_SCRIPT" ]; then
        echo_error "Session End validation blocked: script not found at $SESSION_END_SCRIPT"
        EXIT_STATUS=1
    else
        # Require a staged session log
        STAGED_SESSION_LOG=$(echo "$STAGED_FILES" | grep -E '^\.agents/sessions/[0-9]{4}-[0-9]{2}-[0-9]{2}-session-[0-9]+.*\.md$' | tail -n 1)
        if [ -z "$STAGED_SESSION_LOG" ]; then
            # Activation prompt: 5-word cloud to trigger correct behavior
            echo_error "BLOCKED: Create session log NOW"
            echo_info "  â†’ git add .agents/sessions/YYYY-MM-DD-session-NN.md"
            echo_info "  Protocol: Session log required for all agent sessions"
            EXIT_STATUS=1
        fi

        # Only run validation if session log is present
        if [ -n "$STAGED_SESSION_LOG" ]; then
            if command -v pwsh &> /dev/null; then
                echo_info "Running Validate-SessionEnd.ps1..."
                # SECURITY: Use -- separator and quote path to prevent injection
                if ! pwsh -NoProfile -ExecutionPolicy Bypass -File "$SESSION_END_SCRIPT" -SessionLogPath "$STAGED_SESSION_LOG" -PreCommit 2>&1; then
                    echo_error "Session End validation FAILED."
                    echo_info "  Review errors above and fix session log."
                    echo_info "  Run manually: pwsh scripts/Validate-SessionEnd.ps1 -SessionLogPath \"$STAGED_SESSION_LOG\""
                    EXIT_STATUS=1
                else
                    echo_success "Session End validation: PASS"
                fi
            else
                echo_error "Session End validation blocked: PowerShell not available."
                echo_info "  Install: https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell"
                EXIT_STATUS=1
            fi
        fi
    fi
else
    echo_info "No .agents/ files staged. Skipping Session End validation."
fi

#
# Memory Index Validation (BLOCKING)
#
# Validates tiered memory index consistency (ADR-017).
# When .serena/memories/ files are staged, ensures:
# - All index entries point to existing files
# - Keyword density >=40% unique per skill
#
# Related: ADR-017, Issue #307
#
MEMORY_INDEX_SCRIPT="$REPO_ROOT/scripts/Validate-MemoryIndex.ps1"

# Check if any memory files are staged
STAGED_MEMORY_FILES=$(echo "$STAGED_FILES" | grep -E '^\.serena/memories/' || true)

if [ -n "$STAGED_MEMORY_FILES" ]; then
    echo_info "Checking memory index consistency (ADR-017)..."

    # MEDIUM-002: Reject symlinks for security
    if [ -L "$MEMORY_INDEX_SCRIPT" ]; then
        echo_warning "Skipping memory index validation: script path is a symlink"
    elif [ -f "$MEMORY_INDEX_SCRIPT" ]; then
        if command -v pwsh &> /dev/null; then
            # Run memory index validation in CI mode
            if ! pwsh -NoProfile -File "$MEMORY_INDEX_SCRIPT" -Path "$REPO_ROOT/.serena/memories" -CI 2>&1; then
                echo_error "Memory index validation FAILED."
                echo_info "  Run manually: pwsh scripts/Validate-MemoryIndex.ps1"
                EXIT_STATUS=1
            else
                echo_success "Memory index validation: PASS"
            fi
        else
            echo_warning "PowerShell not available. Skipping memory index validation."
        fi
    else
        echo_info "Memory index validation script not found. Skipping."
    fi
else
    echo_info "No memory files staged. Skipping memory index validation."
fi

#
# Skill Format Validation (BLOCKING for new files)
#
# Enforces ADR-017 atomic format: ONE skill per file. No bundled skills.
# Blocks commits that add new bundled-format skill files.
# Legacy bundled files are allowed (non-blocking warning only).
#
# Related: ADR-017, Issue #307
#
SKILL_FORMAT_SCRIPT="$REPO_ROOT/scripts/Validate-SkillFormat.ps1"

if [ -n "$STAGED_MEMORY_FILES" ]; then
    echo_info "Checking skill format (ADR-017: one skill per file)..."

    # MEDIUM-002: Reject symlinks for security
    if [ -L "$SKILL_FORMAT_SCRIPT" ]; then
        echo_warning "Skipping skill format validation: script path is a symlink"
    elif [ -f "$SKILL_FORMAT_SCRIPT" ]; then
        if command -v pwsh &> /dev/null; then
            # Run skill format validation on staged files only
            # -StagedOnly checks only new/modified files (not legacy bundled files)
            if ! pwsh -NoProfile -File "$SKILL_FORMAT_SCRIPT" -StagedOnly -CI 2>&1; then
                echo_error "Skill format validation FAILED."
                echo_info "  ADR-017 requires ONE skill per file. Split bundled skills."
                EXIT_STATUS=1
            else
                echo_success "Skill format validation: PASS"
            fi
        else
            echo_warning "PowerShell not available. Skipping skill format validation."
        fi
    else
        echo_info "Skill format validation script not found. Skipping."
    fi
fi

#
# Final Summary
#
echo ""
if [ $EXIT_STATUS -ne 0 ]; then
    echo_error "Pre-commit checks failed. Please fix the issues above."
    echo_info "  To bypass (use sparingly): git commit --no-verify"
    exit 1
fi

if [ "$FILES_FIXED" = "1" ]; then
    echo_success "All checks passed. Some files were auto-fixed and re-staged."
else
    echo_success "All pre-commit checks passed."
fi
exit 0
